Target database: ictv_taxonomy_temp
--------------
SET foreign_key_checks = 0
--------------

Query OK, 0 rows affected (0.000 sec)

--------------
DROP TABLE IF EXISTS `species_isolates`
--------------

Query OK, 0 rows affected (0.009 sec)

--------------
DROP TABLE IF EXISTS `taxonomy_change_in`
--------------

Query OK, 0 rows affected (0.008 sec)

--------------
DROP TABLE IF EXISTS `taxonomy_change_out`
--------------

Query OK, 0 rows affected (0.007 sec)

--------------
DROP TABLE IF EXISTS `taxonomy_genome_coverage`
--------------

Query OK, 0 rows affected (0.007 sec)

--------------
DROP TABLE IF EXISTS `taxonomy_host_source`
--------------

Query OK, 0 rows affected (0.007 sec)

--------------
DROP TABLE IF EXISTS `taxonomy_json`
--------------

Query OK, 0 rows affected (0.011 sec)

--------------
DROP TABLE IF EXISTS `taxonomy_json_rank`
--------------

Query OK, 0 rows affected (0.008 sec)

--------------
DROP TABLE IF EXISTS `taxonomy_level`
--------------

Query OK, 0 rows affected (0.008 sec)

--------------
DROP TABLE IF EXISTS `taxonomy_molecule`
--------------

Query OK, 0 rows affected (0.007 sec)

--------------
DROP TABLE IF EXISTS `taxonomy_node`
--------------

Query OK, 0 rows affected (0.012 sec)

--------------
DROP TABLE IF EXISTS `taxonomy_node_delta`
--------------

Query OK, 0 rows affected (0.008 sec)

--------------
DROP TABLE IF EXISTS `taxonomy_node_merge_split`
--------------

Query OK, 0 rows affected (0.009 sec)

--------------
DROP TABLE IF EXISTS `taxonomy_toc`
--------------

Query OK, 0 rows affected (0.008 sec)

--------------
DROP TABLE IF EXISTS `virus_prop`
--------------

Query OK, 0 rows affected, 1 warning (0.006 sec)

Note (Code 1051): Unknown table 'ictv_taxonomy_temp.virus_prop'
--------------
SET foreign_key_checks = 1
--------------

Query OK, 0 rows affected (0.000 sec)

Bye
--------------
CREATE TABLE `taxonomy_change_in` (
  `change` VARCHAR(10) NOT NULL,
  `notes` TEXT,
  PRIMARY KEY (`change`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
--------------

Query OK, 0 rows affected (0.015 sec)

Bye
--------------
CREATE TABLE `taxonomy_change_out` (
  `change` VARCHAR(10) NOT NULL,
  `notes` TEXT,
  PRIMARY KEY (`change`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
--------------

Query OK, 0 rows affected (0.010 sec)

Bye
--------------
CREATE TABLE `taxonomy_genome_coverage` (
  `genome_coverage` VARCHAR(50) NOT NULL,
  `name` VARCHAR(50),
  `priority` INT,
  PRIMARY KEY (`genome_coverage`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
--------------

Query OK, 0 rows affected (0.009 sec)

Bye
--------------
CREATE TABLE `taxonomy_host_source` (
  `host_source` VARCHAR(50) NOT NULL,
  PRIMARY KEY (`host_source`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
--------------

Query OK, 0 rows affected (0.010 sec)

Bye
--------------
CREATE TABLE `taxonomy_level` (
  `id` INT NOT NULL,
  `parent_id` INT,
  `name` VARCHAR(255) NOT NULL,
  `plural` VARCHAR(50),
  `suffix` VARCHAR(50),
  `suffix_viroid` VARCHAR(50),
  `suffix_nuc_acid` VARCHAR(50),
  `suffix_viriform` VARCHAR(50),
  `notes` TEXT,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
--------------

Query OK, 0 rows affected (0.010 sec)

Bye
--------------
CREATE TABLE `taxonomy_molecule` (
  `id` INT NOT NULL,
  `abbrev` VARCHAR(50) NOT NULL,
  `name` VARCHAR(100) NOT NULL,
  `balt_group` INT,
  `balt_roman` VARCHAR(5),
  `description` TEXT,
  `left_idx` INT,
  `right_idx` INT,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
--------------

Query OK, 0 rows affected (0.009 sec)

Bye
--------------
CREATE TABLE `taxonomy_toc`(
    `tree_id` INT NOT NULL,
    `msl_release_num` INT,
    `version_tag` VARCHAR(50) NULL,
    `comments` TEXT,
    UNIQUE INDEX `IX_taxonomy_toc_tree_id` (`tree_id`),
    UNIQUE INDEX `PK_taxonomy_toc` (`tree_id`, `msl_release_num`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
--------------

Query OK, 0 rows affected (0.015 sec)

Bye
--------------
CREATE TABLE `species_isolates` (
  `isolate_id` INT AUTO_INCREMENT NOT NULL,
  `taxnode_id` INT,
  `species_sort` INT,
  `isolate_sort` INT NOT NULL DEFAULT 1,
  `species_name` VARCHAR(100) NOT NULL,
  `isolate_type` CHAR(1) NOT NULL,
  `isolate_names` VARCHAR(500),
  `_isolate_name` VARCHAR(500) GENERATED ALWAYS AS (
    CASE 
      WHEN `isolate_names` LIKE '%;%' 
      THEN LEFT(`isolate_names`, LOCATE(';', `isolate_names`) - 1) 
      ELSE `isolate_names` 
    END
  ) PERSISTENT,
  `isolate_abbrevs` VARCHAR(255),
  `isolate_designation` VARCHAR(500),
  `genbank_accessions` VARCHAR(4000),
  `refseq_accessions` VARCHAR(4000),
  `genome_coverage` VARCHAR(50),
  `molecule` VARCHAR(50),
  `host_source` VARCHAR(50),
  `refseq_organism` VARCHAR(255),
  `refseq_taxids` VARCHAR(4000),
  `update_change` VARCHAR(50),
  `update_prev_species` VARCHAR(100),
  `update_prev_taxnode_id` INT,
  `update_change_proposal` VARCHAR(512),
  `notes` TEXT,
  PRIMARY KEY (`isolate_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
--------------

Query OK, 0 rows affected (0.010 sec)

Bye
--------------
CREATE TABLE `taxonomy_node` (
  `taxnode_id` INT NOT NULL,
  `parent_id` INT,
  `tree_id` INT NOT NULL,
  `msl_release_num` INT,
  `level_id` INT,
  `name` VARCHAR(100),
  `ictv_id` INT,
  `molecule_id` INT,
  `abbrev_csv` LONGTEXT,
  `genbank_accession_csv` LONGTEXT,
  `genbank_refseq_accession_csv` LONGTEXT,
  `refseq_accession_csv` LONGTEXT,
  `isolate_csv` LONGTEXT,
  `notes` LONGTEXT,
  `is_ref` INT NOT NULL,
  `is_official` INT NOT NULL,
  `is_hidden` INT NOT NULL,
  `is_deleted` INT NOT NULL,
  `is_deleted_next_year` INT NOT NULL,
  `is_typo` INT NOT NULL,
  `is_renamed_next_year` INT NOT NULL,
  `is_obsolete` INT NOT NULL,
  `in_change` VARCHAR(10),
  `in_target` VARCHAR(255),
  `in_filename` VARCHAR(255),
  `in_notes` LONGTEXT,
  `out_change` VARCHAR(10),
  `out_target` VARCHAR(255),
  `out_filename` VARCHAR(255),
  `out_notes` LONGTEXT,
  `start_num_sort` INT,
  `row_num` VARCHAR(25),
  `filename` VARCHAR(255),
  `xref` VARCHAR(255),
  `realm_id` INT,
  `realm_kid_ct` INT,
  `realm_desc_ct` INT,
  `subrealm_id` INT,
  `subrealm_kid_ct` INT,
  `subrealm_desc_ct` INT,
  `kingdom_id` INT,
  `kingdom_kid_ct` INT,
  `kingdom_desc_ct` INT,
  `subkingdom_id` INT,
  `subkingdom_kid_ct` INT,
  `subkingdom_desc_ct` INT,
  `phylum_id` INT,
  `phylum_kid_ct` INT,
  `phylum_desc_ct` INT,
  `subphylum_id` INT,
  `subphylum_kid_ct` INT,
  `subphylum_desc_ct` INT,
  `class_id` INT,
  `class_kid_ct` INT,
  `class_desc_ct` INT,
  `subclass_id` INT,
  `subclass_kid_ct` INT,
  `subclass_desc_ct` INT,
  `order_id` INT,
  `order_kid_ct` INT,
  `order_desc_ct` INT,
  `suborder_id` INT,
  `suborder_kid_ct` INT,
  `suborder_desc_ct` INT,
  `family_id` INT,
  `family_kid_ct` INT,
  `family_desc_ct` INT,
  `subfamily_id` INT,
  `subfamily_kid_ct` INT,
  `subfamily_desc_ct` INT,
  `genus_id` INT,
  `genus_kid_ct` INT,
  `genus_desc_ct` INT,
  `subgenus_id` INT,
  `subgenus_kid_ct` INT,
  `subgenus_desc_ct` INT,
  `species_id` INT,
  `species_kid_ct` INT,
  `species_desc_ct` INT,
  `taxa_kid_cts` VARCHAR(200),
  `taxa_desc_cts` VARCHAR(200),
  `inher_molecule_id` INT,
  `left_idx` INT,
  `right_idx` INT,
  `node_depth` INT,
  `lineage` VARCHAR(500),
  `cleaned_name` VARCHAR(100) GENERATED ALWAYS AS (
    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
    REPLACE(REPLACE(`name`, 'í', 'i'), 'é', 'e'), 'ó', 'o'), 'ú', 'u'), 'á', 'a'),
    'ì', 'i'), 'è', 'e'), 'ò', 'o'), 'ù', 'u'), 'à', 'a'), 'î', 'i'), 'ê', 'e'),
    'ô', 'o'), 'û', 'u'), 'â', 'a'), 'ü', 'u'), 'ö', 'o'), 'ï', 'i'), 'ë', 'e'),
    'ä', 'a'), 'ç', 'c'), 'ñ', 'n'), '‘', ''''), '’', ''''), '`', ' '), '  ', ' '),
    'ā', 'a'), 'ī', 'i'), 'ĭ', 'i'), 'ǎ', 'a'), 'ē', 'e'), 'ō', 'o')
  ) PERSISTENT,
  `cleaned_problem` VARCHAR(100) GENERATED ALWAYS AS (
    CASE 
      WHEN INSTR(`name`, 'í') > 0 THEN 'í (accented i)'
      WHEN INSTR(`name`, 'é') > 0 THEN 'é (accented e)'
      WHEN INSTR(`name`, 'ó') > 0 THEN 'ó (accented o)'
      WHEN INSTR(`name`, 'ú') > 0 THEN 'ú (accented u)'
      WHEN INSTR(`name`, 'á') > 0 THEN 'á (accented a)'
      WHEN INSTR(`name`, 'ì') > 0 THEN 'ì (accented i)'
      WHEN INSTR(`name`, 'è') > 0 THEN 'è (accented e)'
      WHEN INSTR(`name`, 'ò') > 0 THEN 'ò (accented o)'
      WHEN INSTR(`name`, 'ù') > 0 THEN 'ù (accented u)'
      WHEN INSTR(`name`, 'à') > 0 THEN 'à (accented a)'
      WHEN INSTR(`name`, 'î') > 0 THEN 'î (accented i)'
      WHEN INSTR(`name`, 'ê') > 0 THEN 'ê (accented e)'
      WHEN INSTR(`name`, 'ô') > 0 THEN 'ô (accented o)'
      WHEN INSTR(`name`, 'û') > 0 THEN 'û (accented u)'
      WHEN INSTR(`name`, 'â') > 0 THEN 'â (accented a)'
      WHEN INSTR(`name`, 'ü') > 0 THEN 'ü (accented u)'
      WHEN INSTR(`name`, 'ö') > 0 THEN 'ö (accented o)'
      WHEN INSTR(`name`, 'ï') > 0 THEN 'ï (accented i)'
      WHEN INSTR(`name`, 'ë') > 0 THEN 'ë (accented e)'
      WHEN INSTR(`name`, 'ä') > 0 THEN 'ä (accented a)'
      WHEN INSTR(`name`, 'ç') > 0 THEN 'ç (accented c)'
      WHEN INSTR(`name`, 'ñ') > 0 THEN 'ñ (accented n)'
      WHEN INSTR(`name`, '‘') > 0 THEN '‘ (Microsoft curvy open single-quote)'
      WHEN INSTR(`name`, '’') > 0 THEN '’ (Microsoft curvy close single-quote)'
      WHEN INSTR(`name`, '`') > 0 THEN '` (ASCII back-quote)'
      WHEN INSTR(`name`, '  ') > 0 THEN '(double space)'
      WHEN INSTR(`name`, 'ā') > 0 THEN 'a-macron'
      WHEN INSTR(`name`, 'ī') > 0 THEN 'i-macron'
      WHEN INSTR(`name`, 'ĭ') > 0 THEN 'i-breve'
      WHEN INSTR(`name`, 'ǎ') > 0 THEN 'a-caron'
      WHEN INSTR(`name`, 'ē') > 0 THEN 'e-macron'
      WHEN INSTR(`name`, 'ō') > 0 THEN 'o-macron'
    END
  ) PERSISTENT,
  `flags` VARCHAR(255) GENERATED ALWAYS AS (
    CONCAT(
      CASE WHEN `tree_id` = `taxnode_id` THEN 'root;' ELSE '' END,
      CASE WHEN `is_hidden` = 1 THEN 'hidden;' ELSE '' END,
      CASE WHEN `is_deleted` = 1 THEN 'deleted;' ELSE '' END,
      CASE WHEN `is_deleted_next_year` = 1 THEN 'removed_next_year;' ELSE '' END,
      CASE WHEN `is_typo` = 1 THEN 'typo;' ELSE '' END,
      CASE WHEN `is_renamed_next_year` = 1 THEN 'renamed_next_year;' ELSE '' END,
      CASE WHEN `is_obsolete` = 1 THEN 'obsolete;' ELSE '' END
    )
  ) PERSISTENT,
  `_numKids` INT GENERATED ALWAYS AS (
    ((`right_idx` - `left_idx`) - 1) / 2
  ) PERSISTENT,
  `_out_target_parent` VARCHAR(255) GENERATED ALWAYS AS (
    RTRIM(LTRIM(REVERSE(SUBSTRING(REPLACE(REVERSE(`out_target`), ';', REPEAT(' ', 1000)), 500, 1500))))
  ) PERSISTENT,
  `_out_target_name` VARCHAR(255) GENERATED ALWAYS AS (
    RTRIM(LTRIM(REVERSE(SUBSTRING(REPLACE(REVERSE(`out_target`), ';', REPEAT(' ', 1000)), 0, 500))))
  ) PERSISTENT,
  `exemplar_name` LONGTEXT,
  `genome_coverage` VARCHAR(50),
  `host_source` VARCHAR(50),
  PRIMARY KEY (`taxnode_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
--------------

Query OK, 0 rows affected (0.011 sec)

Bye
--------------
DROP TABLE IF EXISTS taxonomy_node_merge_split
--------------

Query OK, 0 rows affected, 1 warning (0.006 sec)

Note (Code 1051): Unknown table 'ictv_taxonomy_temp.taxonomy_node_merge_split'
--------------
CREATE TABLE taxonomy_node_merge_split (
    
    prev_ictv_id   INT           NOT NULL ,      
    next_ictv_id   INT           NOT NULL ,      

    
    is_merged      TINYINT(1)    NOT NULL DEFAULT 0 ,
    is_split       TINYINT(1)    NOT NULL DEFAULT 0 ,
    is_recreated   TINYINT(1)    NOT NULL DEFAULT 0 ,
    dist           INT UNSIGNED  NOT NULL DEFAULT 0 ,   
    rev_count      INT UNSIGNED  NOT NULL DEFAULT 0 ,   

    
    PRIMARY KEY (prev_ictv_id, next_ictv_id),

    
    KEY idx_next_ictv_id (next_ictv_id)

) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
--------------

Query OK, 0 rows affected (0.013 sec)

Bye
--------------
CREATE TABLE `taxonomy_node_delta`(
    `prev_taxid` INT NULL DEFAULT NULL,
    `new_taxid` INT NULL DEFAULT NULL,
    `proposal` VARCHAR(255) NULL DEFAULT NULL,
    `notes` TEXT NULL,
    `is_merged` INT NOT NULL DEFAULT 0,
    `is_split` INT NOT NULL DEFAULT 0,
    `is_moved` INT NOT NULL DEFAULT 0,
    `is_promoted` INT NOT NULL DEFAULT 0,
    `is_demoted` INT NOT NULL DEFAULT 0,
    `is_renamed` INT NOT NULL DEFAULT 0,
    `is_new` INT NOT NULL DEFAULT 0,
    `is_deleted` INT NOT NULL DEFAULT 0,
    `is_now_type` INT NOT NULL DEFAULT 0,
    `tag_csv` TEXT AS (CONCAT(
        IF(`is_merged`=1, 'Merged,', ''),
        IF(`is_split`=1, 'Split,', ''),
        IF(`is_renamed`=1, 'Renamed,', ''),
        IF(`is_new`=1, 'New,', ''),
        IF(`is_deleted`=1, 'Abolished,', ''),
        IF(`is_moved`=1, 'Moved,', ''),
        IF(`is_promoted`=1, 'Promoted,', ''),
        IF(`is_demoted`=1, 'Demoted,', ''),
        IF(`is_now_type`=1, 'Assigned as Type Species,', IF(`is_now_type`=-1, 'Removed as Type Species,', ''))
    )),
    `is_lineage_updated` INT NOT NULL DEFAULT 0,
    `msl` INT NOT NULL,
    `tag_csv2` TEXT AS (CONCAT(
        IF(`is_merged`=1, 'Merged,', ''),
        IF(`is_split`=1, 'Split,', ''),
        IF(`is_renamed`=1, 'Renamed,', ''),
        IF(`is_new`=1, 'New,', ''),
        IF(`is_deleted`=1, 'Abolished,', ''),
        IF(`is_moved`=1, 'Moved,', ''),
        IF(`is_promoted`=1, 'Promoted,', ''),
        IF(`is_demoted`=1, 'Demoted,', ''),
        IF(`is_now_type`=1, 'Assigned as Type Species,', IF(`is_now_type`=-1, 'Removed as Type Species,', '')),
        IF(`is_lineage_updated`=1, 'LineageUpdated,', '')
    )) PERSISTENT,
    `tag_csv_min` TEXT AS (CONCAT(
        IF(`is_merged`=1, 'Merged,', ''),
        IF(`is_split`=1, 'Split,', ''),
        IF(`is_renamed`=1, 'Renamed,', ''),
        IF(`is_new`=1, 'New,', ''),
        IF(`is_deleted`=1, 'Abolished,', ''),
        IF(`is_moved`=1, 'Moved,', ''),
        IF(`is_promoted`=1, 'Promoted,', ''),
        IF(`is_demoted`=1, 'Demoted,', '')
    )) PERSISTENT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
--------------

Query OK, 0 rows affected (0.011 sec)

Bye
--------------
CREATE TABLE `taxonomy_json_rank` (
  `id` INT AUTO_INCREMENT NOT NULL,
  `level_id` INT NOT NULL,
  `rank_index` INT NOT NULL,
  `rank_name` VARCHAR(50) NOT NULL,
  `tree_id` INT NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE `UK_taxonomy_json_rank` (`level_id`, `tree_id`),
  UNIQUE `UK_taxonomy_json_rank_rank_tree` (`rank_index`, `tree_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
--------------

Query OK, 0 rows affected (0.014 sec)

Bye
--------------
CREATE TABLE `taxonomy_json` (
  `id` INT AUTO_INCREMENT NOT NULL,
  `taxnode_id` INT,
  `child_counts` VARCHAR(1000),
  `child_json` LONGTEXT,
  `has_assigned_siblings` TINYINT(1),
  `has_species` TINYINT(1),
  `has_unassigned_siblings` CHAR(10),
  `is_ghost_node` TINYINT(1) NOT NULL,
  `json` LONGTEXT,
  `json_lineage` LONGTEXT,
  `parent_distance` INT,
  `parent_id` INT,
  `parent_taxnode_id` INT,
  `rank_index` INT NOT NULL,
  `source` CHAR(1),
  `species_json` LONGTEXT,
  `tree_id` INT,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
--------------

Query OK, 0 rows affected (0.010 sec)

Bye
--------------
LOAD DATA LOCAL INFILE '../../../data/taxonomy_change_in.utf8.txt'
INTO TABLE taxonomy_change_in
CHARACTER SET utf8mb4
FIELDS TERMINATED BY '\t'
OPTIONALLY ENCLOSED BY '"'
ESCAPED BY '"'
LINES TERMINATED BY '\n'
IGNORE 1 ROWS
(
`change`,
notes
)
--------------

Query OK, 2 rows affected (0.002 sec)
Records: 2  Deleted: 0  Skipped: 0  Warnings: 0

Bye
Expected rows for table taxonomy_change_in: 2
--------------
SELECT COUNT(*) AS total_count, 2 AS should_be FROM taxonomy_change_in
--------------

+-------------+-----------+
| total_count | should_be |
+-------------+-----------+
|           2 |         2 |
+-------------+-----------+
1 row in set (0.000 sec)

Bye
--------------
LOAD DATA LOCAL INFILE '../../../data/taxonomy_change_out.utf8.txt'
INTO TABLE taxonomy_change_out
CHARACTER SET utf8mb4
FIELDS TERMINATED BY '\t'
OPTIONALLY ENCLOSED BY '"'
ESCAPED BY '"'
LINES TERMINATED BY '\n'
IGNORE 1 ROWS
(
`change`,
notes
)
--------------

Query OK, 7 rows affected (0.002 sec)
Records: 7  Deleted: 0  Skipped: 0  Warnings: 0

Bye
Expected rows for table taxonomy_change_out: 7
--------------
SELECT COUNT(*) AS total_count, 7 AS should_be FROM taxonomy_change_out
--------------

+-------------+-----------+
| total_count | should_be |
+-------------+-----------+
|           7 |         7 |
+-------------+-----------+
1 row in set (0.000 sec)

Bye
--------------
LOAD DATA LOCAL INFILE '../../../data/taxonomy_genome_coverage.utf8.txt'
INTO TABLE taxonomy_genome_coverage
CHARACTER SET utf8mb4
FIELDS TERMINATED BY '\t'
OPTIONALLY ENCLOSED BY '"'
ESCAPED BY '"'
LINES TERMINATED BY '\n'
IGNORE 1 ROWS
(
genome_coverage,
name,
priority
)
--------------

Query OK, 5 rows affected (0.002 sec)
Records: 5  Deleted: 0  Skipped: 0  Warnings: 0

Bye
Expected rows for table taxonomy_genome_coverage: 5
--------------
SELECT COUNT(*) AS total_count, 5 AS should_be FROM taxonomy_genome_coverage
--------------

+-------------+-----------+
| total_count | should_be |
+-------------+-----------+
|           5 |         5 |
+-------------+-----------+
1 row in set (0.000 sec)

Bye
--------------
LOAD DATA LOCAL INFILE '../../../data/taxonomy_host_source.utf8.txt'
INTO TABLE taxonomy_host_source
CHARACTER SET utf8mb4
FIELDS TERMINATED BY '\t'
OPTIONALLY ENCLOSED BY '"'
ESCAPED BY '"'
LINES TERMINATED BY '\n'
IGNORE 1 ROWS
(
host_source
)
--------------

Query OK, 27 rows affected (0.002 sec)
Records: 27  Deleted: 0  Skipped: 0  Warnings: 0

Bye
Expected rows for table taxonomy_host_source: 27
--------------
SELECT COUNT(*) AS total_count, 27 AS should_be FROM taxonomy_host_source
--------------

+-------------+-----------+
| total_count | should_be |
+-------------+-----------+
|          27 |        27 |
+-------------+-----------+
1 row in set (0.000 sec)

Bye
--------------
LOAD DATA LOCAL INFILE '../../../data/taxonomy_level.utf8.txt'
INTO TABLE taxonomy_level
CHARACTER SET utf8mb4
FIELDS TERMINATED BY '\t'
OPTIONALLY ENCLOSED BY '"'
ESCAPED BY '"'
LINES TERMINATED BY '\n'
IGNORE 1 ROWS
(
  id,
  parent_id,
  `name`,
  plural,
  suffix,
  suffix_viroid,
  suffix_nuc_acid,
  suffix_viriform,
  notes
)
--------------

Query OK, 16 rows affected (0.003 sec)
Records: 16  Deleted: 0  Skipped: 0  Warnings: 0

Bye
Expected rows for table taxonomy_level: 16
--------------
SELECT COUNT(*) AS total_count, 16 AS should_be FROM taxonomy_level
--------------

+-------------+-----------+
| total_count | should_be |
+-------------+-----------+
|          16 |        16 |
+-------------+-----------+
1 row in set (0.000 sec)

Bye
--------------
LOAD DATA LOCAL INFILE '../../../data/taxonomy_molecule.utf8.txt'
INTO TABLE taxonomy_molecule
CHARACTER SET utf8mb4
FIELDS TERMINATED BY '\t'
OPTIONALLY ENCLOSED BY '"'
ESCAPED BY '"'
LINES TERMINATED BY '\n'
IGNORE 1 ROWS
(
  id,
  abbrev,
  `name`,
  balt_group,
  balt_roman,
  `description`,
  left_idx,
  right_idx
)
--------------

Query OK, 16 rows affected (0.002 sec)
Records: 16  Deleted: 0  Skipped: 0  Warnings: 0

Bye
Expected rows for table taxonomy_molecule: 16
--------------
SELECT COUNT(*) AS total_count, 16 AS should_be FROM taxonomy_molecule
--------------

+-------------+-----------+
| total_count | should_be |
+-------------+-----------+
|          16 |        16 |
+-------------+-----------+
1 row in set (0.000 sec)

Bye
--------------
LOAD DATA LOCAL INFILE '../../../data/taxonomy_toc.utf8.txt'
INTO TABLE taxonomy_toc
CHARACTER SET utf8mb4
FIELDS TERMINATED BY '\t'
OPTIONALLY ENCLOSED BY '"'
ESCAPED BY '"'
LINES TERMINATED BY '\n'
IGNORE 1 ROWS
(
  tree_id,
  msl_release_num,
  version_tag,
  comments
)
--------------

Query OK, 40 rows affected (0.003 sec)
Records: 40  Deleted: 0  Skipped: 0  Warnings: 0

Bye
Expected rows for table taxonomy_toc: 40
--------------
SELECT COUNT(*) AS total_count, 40 AS should_be FROM taxonomy_toc
--------------

+-------------+-----------+
| total_count | should_be |
+-------------+-----------+
|          40 |        40 |
+-------------+-----------+
1 row in set (0.000 sec)

Bye
--------------
LOAD DATA LOCAL INFILE '../../../data/taxonomy_node_mariadb_etl.utf8.txt'
INTO TABLE taxonomy_node
CHARACTER SET utf8mb4
FIELDS TERMINATED BY '\t'
OPTIONALLY ENCLOSED BY '"'
ESCAPED BY '"'
LINES TERMINATED BY '\n'
IGNORE 1 ROWS
(
  taxnode_id,
  parent_id,
  tree_id,
  msl_release_num,
  level_id,
  name,
  ictv_id,
  molecule_id,
  abbrev_csv,
  genbank_accession_csv,
  genbank_refseq_accession_csv,
  refseq_accession_csv,
  isolate_csv,
  notes,
  is_ref,
  is_official,
  is_hidden,
  is_deleted,
  is_deleted_next_year,
  is_typo,
  is_renamed_next_year,
  is_obsolete,
  in_change,
  in_target,
  in_filename,
  in_notes,
  out_change,
  out_target,
  out_filename,
  out_notes,
  start_num_sort,
  row_num,
  filename,
  xref,
  realm_id,
  realm_kid_ct,
  realm_desc_ct,
  subrealm_id,
  subrealm_kid_ct,
  subrealm_desc_ct,
  kingdom_id,
  kingdom_kid_ct,
  kingdom_desc_ct,
  subkingdom_id,
  subkingdom_kid_ct,
  subkingdom_desc_ct,
  phylum_id,
  phylum_kid_ct,
  phylum_desc_ct,
  subphylum_id,
  subphylum_kid_ct,
  subphylum_desc_ct,
  class_id,
  class_kid_ct,
  class_desc_ct,
  subclass_id,
  subclass_kid_ct,
  subclass_desc_ct,
  order_id,
  order_kid_ct,
  order_desc_ct,
  suborder_id,
  suborder_kid_ct,
  suborder_desc_ct,
  family_id,
  family_kid_ct,
  family_desc_ct,
  subfamily_id,
  subfamily_kid_ct,
  subfamily_desc_ct,
  genus_id,
  genus_kid_ct,
  genus_desc_ct,
  subgenus_id,
  subgenus_kid_ct,
  subgenus_desc_ct,
  species_id,
  species_kid_ct,
  species_desc_ct,
  taxa_kid_cts,
  taxa_desc_cts,
  inher_molecule_id,
  left_idx,
  right_idx,
  node_depth,
  lineage,
  exemplar_name,
  genome_coverage,
  host_source
)
--------------

Query OK, 172699 rows affected (6.867 sec)
Records: 172699  Deleted: 0  Skipped: 0  Warnings: 0

Bye
Expected rows for table taxonomy_node: 172699
--------------
SELECT COUNT(*) AS total_count, 172699 AS should_be FROM taxonomy_node
--------------

+-------------+-----------+
| total_count | should_be |
+-------------+-----------+
|      172699 |    172699 |
+-------------+-----------+
1 row in set (0.108 sec)

Bye
--------------
LOAD DATA LOCAL INFILE '../../../data/species_isolates.utf8.txt'
INTO TABLE species_isolates
CHARACTER SET utf8mb4
FIELDS TERMINATED BY '\t'
OPTIONALLY ENCLOSED BY '"'
ESCAPED BY '"'
LINES TERMINATED BY '\n'
IGNORE 1 ROWS
(
  isolate_id,
  taxnode_id,
  species_sort,
  isolate_sort,
  species_name,
  isolate_type,
  isolate_names,
  isolate_abbrevs,
  isolate_designation,
  genbank_accessions,
  refseq_accessions,
  genome_coverage,
  molecule,
  host_source,
  refseq_organism,
  refseq_taxids,
  update_change,
  update_prev_species,
  update_prev_taxnode_id,
  update_change_proposal,
  @computed_col,               
  notes
)
--------------

Query OK, 18095 rows affected (0.288 sec)
Records: 18095  Deleted: 0  Skipped: 0  Warnings: 0

--------------
SET @autoIncVal := (
  SELECT COALESCE(MAX(isolate_id), 0) + 1
  FROM species_isolates
)
--------------

Query OK, 0 rows affected (0.000 sec)

--------------
SET @sql = CONCAT('ALTER TABLE species_isolates AUTO_INCREMENT = ', @autoIncVal)
--------------

Query OK, 0 rows affected (0.000 sec)

--------------
PREPARE st FROM @sql
--------------

Query OK, 0 rows affected (0.000 sec)
Statement prepared

--------------
EXECUTE st
--------------

Query OK, 0 rows affected (0.010 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
DEALLOCATE PREPARE st
--------------

Query OK, 0 rows affected (0.000 sec)

Bye
Expected rows for table species_isolates: 18095
--------------
SELECT COUNT(*) AS total_count, 18095 AS should_be FROM species_isolates
--------------

+-------------+-----------+
| total_count | should_be |
+-------------+-----------+
|       18095 |     18095 |
+-------------+-----------+
1 row in set (0.005 sec)

Bye
--------------
LOAD DATA LOCAL INFILE '../../../data/taxonomy_node_merge_split.utf8.txt'
INTO TABLE taxonomy_node_merge_split
CHARACTER SET utf8mb4
FIELDS TERMINATED BY '\t'
OPTIONALLY ENCLOSED BY '"'
ESCAPED BY '"'
LINES TERMINATED BY '\n'
IGNORE 1 ROWS
(
  prev_ictv_id,
  next_ictv_id,
  is_merged,
  is_split,
  is_recreated,
  dist,
  rev_count
)
--------------

Query OK, 38842 rows affected (0.258 sec)
Records: 38842  Deleted: 0  Skipped: 0  Warnings: 0

Bye
Expected rows for table taxonomy_node_merge_split: 38842
--------------
SELECT COUNT(*) AS total_count, 38842 AS should_be FROM taxonomy_node_merge_split
--------------

+-------------+-----------+
| total_count | should_be |
+-------------+-----------+
|       38842 |     38842 |
+-------------+-----------+
1 row in set (0.010 sec)

Bye
--------------
LOAD DATA LOCAL INFILE '../../../data/taxonomy_node_delta.utf8.txt'
INTO TABLE taxonomy_node_delta
CHARACTER SET utf8mb4
FIELDS TERMINATED BY '\t'
OPTIONALLY ENCLOSED BY '"'
ESCAPED BY '"'
LINES TERMINATED BY '\n'
IGNORE 1 ROWS
(
  prev_taxid,
  new_taxid,
  proposal,
  notes,
  is_merged,
  is_split,
  is_moved,
  is_promoted,
  is_demoted,
  is_renamed,
  is_new,
  is_deleted,
  is_now_type,
  @dummy_tag_csv,          
  is_lineage_updated,
  msl,
  @dummy_tag_csv2,         
  @dummy_tag_csv_min
)
SET 
  tag_csv = NULL,
  tag_csv2 = NULL,
  tag_csv_min = NULL
--------------

Query OK, 174745 rows affected (1.094 sec)
Records: 174745  Deleted: 0  Skipped: 0  Warnings: 0

Bye
Expected rows for table taxonomy_node_delta: 174745
--------------
SELECT COUNT(*) AS total_count, 174745 AS should_be FROM taxonomy_node_delta
--------------

+-------------+-----------+
| total_count | should_be |
+-------------+-----------+
|      174745 |    174745 |
+-------------+-----------+
1 row in set (0.052 sec)

Bye
--------------
DROP VIEW IF EXISTS `taxonomy_node_names`
--------------

Query OK, 0 rows affected (0.003 sec)

--------------
CREATE VIEW `taxonomy_node_names` AS
SELECT 
    
    tn.*,
    
    tn.`msl_release_num` AS `msl`,
    
    COALESCE(`rank`.`name`, '') AS `rank`,
    COALESCE(`tree`.`name`, '') AS `tree`,
    COALESCE(`realm`.`name`, '') AS `realm`,
    COALESCE(`subrealm`.`name`, '') AS `subrealm`,
    COALESCE(`kingdom`.`name`, '') AS `kingdom`,
    COALESCE(`subkingdom`.`name`, '') AS `subkingdom`,
    COALESCE(`phylum`.`name`, '') AS `phylum`,
    COALESCE(`subphylum`.`name`, '') AS `subphylum`,
    COALESCE(`class`.`name`, '') AS `class`,
    COALESCE(`subclass`.`name`, '') AS `subclass`,
    COALESCE(`order`.`name`, '') AS `order`,
    COALESCE(`suborder`.`name`, '') AS `suborder`,
    COALESCE(`family`.`name`, '') AS `family`,
    COALESCE(`subfamily`.`name`, '') AS `subfamily`,
    COALESCE(`genus`.`name`, '') AS `genus`,
    COALESCE(`subgenus`.`name`, '') AS `subgenus`,
    COALESCE(`species`.`name`, '') AS `species`,
    COALESCE(mol.`abbrev`, '') AS `molecule`,
    COALESCE(imol.`abbrev`, '') AS `inher_molecule`,
    COALESCE(gcov.`name`, '') AS `genome_coverage_name`
FROM 
    taxonomy_node tn

LEFT OUTER JOIN taxonomy_level `rank` ON `rank`.`id` = tn.`level_id`
LEFT OUTER JOIN taxonomy_node `tree` ON `tree`.`taxnode_id` = tn.`tree_id`
LEFT OUTER JOIN taxonomy_node `realm` ON `realm`.`taxnode_id` = tn.`realm_id`
LEFT OUTER JOIN taxonomy_node `subrealm` ON `subrealm`.`taxnode_id` = tn.`subrealm_id`
LEFT OUTER JOIN taxonomy_node `kingdom` ON `kingdom`.`taxnode_id` = tn.`kingdom_id`
LEFT OUTER JOIN taxonomy_node `subkingdom` ON `subkingdom`.`taxnode_id` = tn.`subkingdom_id`
LEFT OUTER JOIN taxonomy_node `phylum` ON `phylum`.`taxnode_id` = tn.`phylum_id`
LEFT OUTER JOIN taxonomy_node `subphylum` ON `subphylum`.`taxnode_id` = tn.`subphylum_id`
LEFT OUTER JOIN taxonomy_node `class` ON `class`.`taxnode_id` = tn.`class_id`
LEFT OUTER JOIN taxonomy_node `subclass` ON `subclass`.`taxnode_id` = tn.`subclass_id`
LEFT OUTER JOIN taxonomy_node `order` ON `order`.`taxnode_id` = tn.`order_id`
LEFT OUTER JOIN taxonomy_node `suborder` ON `suborder`.`taxnode_id` = tn.`suborder_id`
LEFT OUTER JOIN taxonomy_node `family` ON `family`.`taxnode_id` = tn.`family_id`
LEFT OUTER JOIN taxonomy_node `subfamily` ON `subfamily`.`taxnode_id` = tn.`subfamily_id`
LEFT OUTER JOIN taxonomy_node `genus` ON `genus`.`taxnode_id` = tn.`genus_id`
LEFT OUTER JOIN taxonomy_node `subgenus` ON `subgenus`.`taxnode_id` = tn.`subgenus_id`
LEFT OUTER JOIN taxonomy_node `species` ON `species`.`taxnode_id` = tn.`species_id`

LEFT OUTER JOIN taxonomy_molecule mol ON mol.`id` = tn.`molecule_id`
LEFT OUTER JOIN taxonomy_molecule imol ON imol.`id` = tn.`inher_molecule_id`
LEFT OUTER JOIN taxonomy_genome_coverage gcov ON gcov.`genome_coverage` = tn.`genome_coverage`

WHERE 
    tn.`is_deleted` = 0 
    AND tn.`is_hidden` = 0 
    AND tn.`is_obsolete` = 0
--------------

Query OK, 0 rows affected (0.007 sec)

Bye
--------------
DROP VIEW IF EXISTS `taxonomy_node_changes`
--------------

Query OK, 0 rows affected (0.003 sec)

--------------
CREATE VIEW `taxonomy_node_changes` AS
SELECT
    bone.ictv_id,
    bone.msl,
    nt.next_tag,
    nt.next_tag_ct,
    n.left_idx,
    n.taxnode_id,
    n.rank,
    n.name,
    pt.prev_tag,
    pt.prev_tag_ct
FROM
    (
        SELECT 
            ids.ictv_id,
            msl.msl
        FROM (
            SELECT ictv_id
            FROM taxonomy_node_names
            WHERE msl IS NOT NULL
            GROUP BY ictv_id
        ) AS ids
        CROSS JOIN (
            SELECT msl_release_num AS msl
            FROM taxonomy_toc
            WHERE msl_release_num IS NOT NULL
            GROUP BY msl_release_num
        ) AS msl
    ) AS bone
LEFT OUTER JOIN taxonomy_node_names n 
    ON n.msl_release_num = bone.msl 
    AND n.ictv_id = bone.ictv_id
LEFT JOIN (
    SELECT
        sub.prev_taxid AS taxnode_id,
        GROUP_CONCAT(sub.ct_tag ORDER BY sub.tag_csv_min SEPARATOR '|') AS next_tag,
        SUM(sub.cnt) AS next_tag_ct
    FROM (
        SELECT
            d.prev_taxid,
            d.tag_csv_min,
            COUNT(*) AS cnt,
            CONCAT(
                LEFT(d.tag_csv_min, CASE WHEN d.tag_csv_min = '' THEN 1 ELSE LENGTH(d.tag_csv_min) - 1 END),
                CASE WHEN COUNT(*) > 1 THEN CONCAT('(N=', COUNT(*), ')') ELSE '' END
            ) AS ct_tag
        FROM taxonomy_node_delta d
        GROUP BY d.prev_taxid, d.tag_csv_min
    ) sub
    GROUP BY sub.prev_taxid
) AS nt ON nt.taxnode_id = n.taxnode_id
LEFT JOIN (
    SELECT
        sub.new_taxid AS taxnode_id,
        REPLACE(
            GROUP_CONCAT(sub.ct_tag ORDER BY sub.tag_csv_min SEPARATOR '|'),
            ',(',
            '('
        ) AS prev_tag,
        SUM(sub.cnt) AS prev_tag_ct
    FROM (
        SELECT
            d.new_taxid,
            d.tag_csv_min,
            COUNT(*) AS cnt,
            CONCAT(
                LEFT(d.tag_csv_min, CASE WHEN d.tag_csv_min = '' THEN 1 ELSE LENGTH(d.tag_csv_min) - 1 END),
                CASE WHEN COUNT(*) > 1 THEN CONCAT('(N=', COUNT(*), ')') ELSE '' END
            ) AS ct_tag
        FROM taxonomy_node_delta d
        GROUP BY d.new_taxid, d.tag_csv_min
    ) sub
    GROUP BY sub.new_taxid
) AS pt ON pt.taxnode_id = n.taxnode_id
--------------

Query OK, 0 rows affected (0.008 sec)

Bye
--------------
DROP VIEW IF EXISTS `MSL_export_fast`
--------------

Query OK, 0 rows affected (0.003 sec)

--------------
CREATE VIEW `MSL_export_fast` AS
SELECT 
    
    
    tn.left_idx,
    
    
    IFNULL(`realm`.name, '') AS `realm`,
    IFNULL(`subrealm`.name, '') AS `subrealm`,
    IFNULL(`kingdom`.name, '') AS `kingdom`,
    IFNULL(`subkingdom`.name, '') AS `subkingdom`,
    IFNULL(`phylum`.name, '') AS `phylum`,
    IFNULL(`subphylum`.name, '') AS `subphylum`,
    IFNULL(`class`.name, '') AS `class`,
    IFNULL(`subclass`.name, '') AS `subclass`,
    IFNULL(`order`.name, '') AS `order`,
    IFNULL(`suborder`.name, '') AS `suborder`,
    IFNULL(`family`.name, '') AS `family`,
    IFNULL(`subfamily`.name, '') AS `subfamily`,
    IFNULL(`genus`.name, '') AS `genus`,
    IFNULL(`subgenus`.name, '') AS `subgenus`,
    IFNULL(`species`.name, '') AS `species`,
    tn.is_ref AS is_type_species,
    
    
    IFNULL(imol.abbrev, '') AS inher_molecule,
    
    
    (SELECT `rank` FROM taxonomy_node_names tns 
     WHERE tns.tree_id = tn.tree_id 
       AND tn.left_idx BETWEEN tns.left_idx AND tns.right_idx 
       AND tns.molecule_id = tn.inher_molecule_id 
     ORDER BY tns.node_depth DESC LIMIT 1) AS inher_molecule_src,

    
    IFNULL((SELECT tag_csv FROM taxonomy_node_delta WHERE new_taxid = tn.taxnode_id LIMIT 1), '') AS last_change,

    
    CASE 
        WHEN (SELECT tag_csv FROM taxonomy_node_delta WHERE new_taxid = tn.taxnode_id LIMIT 1) <> '' 
        THEN RTRIM(tn.msl_release_num)
        ELSE ''
    END AS last_change_msl,

    
    IFNULL((SELECT proposal FROM taxonomy_node_delta WHERE new_taxid = tn.taxnode_id LIMIT 1), '') AS last_change_proposal,

    
    CONCAT('=HYPERLINK("http://ictvonline.org/taxonomy/p/taxonomy-history?taxnode_id=', RTRIM(tn.taxnode_id), '","ICTVonline=', RTRIM(tn.taxnode_id), '")') AS history_url,

    
    IFNULL(tn.abbrev_csv, '') AS FYI_last_abbrev,
    IFNULL(tn.genbank_accession_csv, '') AS last_ncbi,
    IFNULL(tn.isolate_csv, '') AS last_isolates,

    
    tn.tree_id,
    tn.msl_release_num

FROM taxonomy_node tn


LEFT JOIN taxonomy_node `tree` ON `tree`.taxnode_id = tn.tree_id
LEFT JOIN taxonomy_node `realm` ON `realm`.taxnode_id = tn.realm_id
LEFT JOIN taxonomy_node `subrealm` ON `subrealm`.taxnode_id = tn.subrealm_id
LEFT JOIN taxonomy_node `kingdom` ON `kingdom`.taxnode_id = tn.kingdom_id
LEFT JOIN taxonomy_node `subkingdom` ON `subkingdom`.taxnode_id = tn.subkingdom_id
LEFT JOIN taxonomy_node `phylum` ON `phylum`.taxnode_id = tn.phylum_id
LEFT JOIN taxonomy_node `subphylum` ON `subphylum`.taxnode_id = tn.subphylum_id
LEFT JOIN taxonomy_node `class` ON `class`.taxnode_id = tn.class_id
LEFT JOIN taxonomy_node `subclass` ON `subclass`.taxnode_id = tn.subclass_id
LEFT JOIN taxonomy_node `order` ON `order`.taxnode_id = tn.order_id
LEFT JOIN taxonomy_node `suborder` ON `suborder`.taxnode_id = tn.suborder_id
LEFT JOIN taxonomy_node `family` ON `family`.taxnode_id = tn.family_id
LEFT JOIN taxonomy_node `subfamily` ON `subfamily`.taxnode_id = tn.subfamily_id
LEFT JOIN taxonomy_node `genus` ON `genus`.taxnode_id = tn.genus_id
LEFT JOIN taxonomy_node `subgenus` ON `subgenus`.taxnode_id = tn.subgenus_id
LEFT JOIN taxonomy_node `species` ON `species`.taxnode_id = tn.species_id
LEFT JOIN taxonomy_molecule mol ON mol.id = tn.molecule_id
LEFT JOIN taxonomy_molecule imol ON imol.id = tn.inher_molecule_id

WHERE tn.is_deleted = 0 
  AND tn.is_hidden = 0 
  AND tn.is_obsolete = 0
  AND tn.level_id = 600
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP VIEW IF EXISTS `species_historic_name_lut`
--------------

Query OK, 0 rows affected (0.003 sec)

--------------
CREATE VIEW `species_historic_name_lut` AS
SELECT
    MIN(old.msl_release_num) AS first_msl,
    MAX(old.msl_release_num) AS last_msl,
    old.name AS old_name,
    old.ictv_id AS old_ictv_id,
    CASE 
        WHEN MAX(new.taxnode_id) IS NULL THEN 'abolished'
        WHEN old.name = MAX(new.name) AND old.name = MIN(new.name) THEN 'same'
        WHEN old.name <> MAX(new.name) AND MAX(new.name) = MIN(new.name) AND MAX(is_merged) = 1 THEN 'renamed/merged'
        WHEN old.name <> MAX(new.name) AND MAX(new.name) = MIN(new.name) AND MAX(is_merged) = 0 THEN 'renamed'
        WHEN MAX(new.name) <> MIN(new.name) THEN 'split'
        ELSE 'error'
    END AS action,
    MAX(new.msl_release_num) AS new_msl,
    MAX(new.name) AS new_name,
    MAX(new.taxnode_id) AS new_taxnode_id,
    CASE 
        WHEN MAX(new.name) = MIN(new.name) THEN '===='
        ELSE CONCAT('<', RTRIM(COUNT(DISTINCT new.name)), '>')
    END AS sep2,
    MAX(ms.is_merged) AS is_merge,
    MAX(ms.is_split) AS is_split,
    MIN(new.name) AS new_name2,
    MIN(new.taxnode_id) AS new_taxnode_id2,
    MAX(new.left_idx) AS new_sort
FROM taxonomy_node_names old
LEFT OUTER JOIN taxonomy_node_merge_split ms 
    ON ms.prev_ictv_id = old.ictv_id 
    AND ms.rev_count = 0
LEFT OUTER JOIN taxonomy_node_names new 
    ON ms.next_ictv_id = new.ictv_id 
    AND new.msl_release_num = (SELECT MAX(msl_release_num) FROM taxonomy_toc)
    AND new.rank = 'species'
WHERE old.msl_release_num IS NOT NULL 
AND old.level_id = 600
GROUP BY old.name, old.ictv_id
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP VIEW IF EXISTS species_isolates_alpha_num1_num2
--------------

Query OK, 0 rows affected (0.003 sec)

--------------
CREATE VIEW species_isolates_alpha_num1_num2 AS
SELECT
  t.isolate_id,
  t.taxnode_id,
  t.species_name,
  t.isolate_type,
  t.isolate_names,
  t.isolate_abbrevs,
  t.isolate_designation,
  t._isolate_name,

  
  t._isolate_name_alpha,

  
  CASE
    WHEN t._isolate_name_num1_str REGEXP '^[0-9]+$' AND t._isolate_name_num1_str <> ''
      THEN CAST(t._isolate_name_num1_str AS UNSIGNED)
    ELSE NULL
  END AS _isolate_name_num1,

  CASE
    WHEN t._isolate_name_num2_str REGEXP '^[0-9]+$' AND t._isolate_name_num2_str <> ''
      THEN CAST(t._isolate_name_num2_str AS UNSIGNED)
    ELSE NULL
  END AS _isolate_name_num2

FROM (
  SELECT
    si.*,

    
    TRIM(
      COALESCE(
        REGEXP_REPLACE(si._isolate_name,
                       '([._-]?[0-9]+(?:[._][0-9]+)?)$', 
                       ''),
        si._isolate_name
      )
    ) AS _isolate_name_alpha,

    
    REGEXP_SUBSTR(si._isolate_name, '[._-]?[0-9]+(?:[._][0-9]+)?$') AS tail_any,
    REGEXP_SUBSTR(si._isolate_name, '[._-]?[0-9]+[._][0-9]+$')      AS tail_two,

    
    REGEXP_REPLACE(
      REGEXP_SUBSTR(si._isolate_name, '[._-]?[0-9]+(?:[._][0-9]+)?$'),
      '^[._-]?([0-9]+)(?:[._][0-9]+)?$','\\1'
    ) AS _isolate_name_num1_str,

    
    REGEXP_REPLACE(
      REGEXP_SUBSTR(si._isolate_name, '[._-]?[0-9]+[._][0-9]+$'),
      '^[._-]?[0-9]+[._]([0-9]+)$','\\1'
    ) AS _isolate_name_num2_str

  FROM species_isolates AS si
) AS t
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP VIEW IF EXISTS `species_latest`
--------------

Query OK, 0 rows affected (0.003 sec)

--------------
CREATE VIEW `species_latest` AS


SELECT 
    tn.taxnode_id AS taxnode_id,
    tn.msl_release_num AS msl_release_num,
    tn.name AS name,
    tn.rank AS `rank`,
    
    tn.molecule AS molecule,
    
    
    (SELECT genome_coverage
     FROM taxonomy_node prev 
     WHERE prev.ictv_id = tn.ictv_id
     AND prev.genome_coverage IS NOT NULL
     ORDER BY prev.msl_release_num DESC
     LIMIT 1) AS genome_coverage,
    
    (SELECT msl_release_num
     FROM taxonomy_node prev 
     WHERE prev.ictv_id = tn.ictv_id
     AND prev.genome_coverage IS NOT NULL
     ORDER BY prev.msl_release_num DESC
     LIMIT 1) AS genome_coverage_msl,
    
    
    (SELECT host_source
     FROM taxonomy_node prev 
     WHERE prev.ictv_id = tn.ictv_id
     AND prev.host_source IS NOT NULL
     ORDER BY prev.msl_release_num DESC
     LIMIT 1) AS host_source,
    
    (SELECT msl_release_num
     FROM taxonomy_node prev 
     WHERE prev.ictv_id = tn.ictv_id
     AND prev.host_source IS NOT NULL
     ORDER BY prev.msl_release_num DESC
     LIMIT 1) AS host_source_msl,
    
    
    (SELECT exemplar_name
     FROM taxonomy_node prev 
     WHERE prev.ictv_id = tn.ictv_id
     AND prev.exemplar_name IS NOT NULL
     ORDER BY prev.msl_release_num DESC
     LIMIT 1) AS exemplar_name,
    
    (SELECT msl_release_num
     FROM taxonomy_node prev 
     WHERE prev.ictv_id = tn.ictv_id
     AND prev.exemplar_name IS NOT NULL
     ORDER BY prev.msl_release_num DESC
     LIMIT 1) AS exemplar_name_msl,
    
    
    (SELECT abbrev_csv
     FROM taxonomy_node prev 
     WHERE prev.ictv_id = tn.ictv_id
     AND prev.abbrev_csv IS NOT NULL
     ORDER BY prev.msl_release_num DESC
     LIMIT 1) AS abbrev_csv,
    
    (SELECT msl_release_num
     FROM taxonomy_node prev 
     WHERE prev.ictv_id = tn.ictv_id
     AND prev.abbrev_csv IS NOT NULL
     ORDER BY prev.msl_release_num DESC
     LIMIT 1) AS abbrev_csv_msl,
    
    
    (SELECT isolate_csv
     FROM taxonomy_node prev 
     WHERE prev.ictv_id = tn.ictv_id
     AND prev.isolate_csv IS NOT NULL
     ORDER BY prev.msl_release_num DESC
     LIMIT 1) AS isolate_csv,
    
    (SELECT msl_release_num
     FROM taxonomy_node prev 
     WHERE prev.ictv_id = tn.ictv_id
     AND prev.isolate_csv IS NOT NULL
     ORDER BY prev.msl_release_num DESC
     LIMIT 1) AS isolate_csv_msl,
    
    
    (SELECT genbank_accession_csv
     FROM taxonomy_node prev 
     WHERE prev.ictv_id = tn.ictv_id
     AND prev.genbank_accession_csv IS NOT NULL
     ORDER BY prev.msl_release_num DESC
     LIMIT 1) AS genbank_accession_csv,
    
    (SELECT msl_release_num
     FROM taxonomy_node prev 
     WHERE prev.ictv_id = tn.ictv_id
     AND prev.genbank_accession_csv IS NOT NULL
     ORDER BY prev.msl_release_num DESC
     LIMIT 1) AS genbank_accession_csv_msl
     
FROM taxonomy_node_names tn
WHERE tn.msl_release_num = (SELECT MAX(msl_release_num) FROM taxonomy_toc)
AND `rank` = 'species'
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP VIEW IF EXISTS `taxonomy_node_dx`
--------------

Query OK, 0 rows affected (0.003 sec)

--------------
CREATE VIEW `taxonomy_node_dx` AS
SELECT 
    pt.level_id AS prev_level, 
    pd.prev_taxid AS prev_id, 
    pt.ictv_id AS prev_ictv_id, 
    pd.tag_csv AS prev_tags, 
    pt.name AS prev_name, 
    pt.lineage AS prev_lineage, 
    pd.proposal AS prev_proposal,
    
    nt.level_id AS next_level, 
    nd.new_taxid AS next_id, 
    nt.ictv_id AS next_ictv_id, 
    nd.tag_csv AS next_tags, 
    nt.name AS next_name, 
    nt.lineage AS next_lineage, 
    nd.proposal AS next_proposal,
    
    t.*
FROM taxonomy_node t
LEFT OUTER JOIN taxonomy_node_delta pd 
    ON pd.new_taxid = t.taxnode_id
LEFT OUTER JOIN taxonomy_node pt 
    ON pt.taxnode_id = pd.prev_taxid
LEFT OUTER JOIN taxonomy_node_delta nd 
    ON nd.prev_taxid = t.taxnode_id
LEFT OUTER JOIN taxonomy_node nt 
    ON nt.taxnode_id = nd.new_taxid
--------------

Query OK, 0 rows affected (0.003 sec)

Bye
--------------
DROP VIEW IF EXISTS `taxonomy_node_export`
--------------

Query OK, 0 rows affected (0.003 sec)

--------------
CREATE VIEW `taxonomy_node_export` AS






SELECT 
    tn.`taxnode_id`,
    tn.`parent_id`,
    tn.`tree_id`,
    tn.`msl_release_num`,
    tn.`level_id`,
    tn.`name`,
    tn.`ictv_id`,
    tn.`molecule_id`,
    tn.`abbrev_csv`,
    tn.`genbank_accession_csv`,
    tn.`genbank_refseq_accession_csv`,
    tn.`refseq_accession_csv`,
    tn.`isolate_csv`,
    REPLACE(tn.`notes`, '\r', '') AS notes, 
    tn.`is_ref`,
    tn.`is_official`,
    tn.`is_hidden`,
    tn.`is_deleted`,
    tn.`is_deleted_next_year`,
    tn.`is_typo`,
    tn.`is_renamed_next_year`,
    tn.`is_obsolete`,
    tn.`in_change`,
    tn.`in_target`,
    tn.`in_filename`,
    tn.`in_notes`,
    tn.`out_change`,
    tn.`out_target`,
    tn.`out_filename`,
    tn.`out_notes`,
    tn.`lineage`,
    tn.`cleaned_name`,
    COALESCE(`rank`.`name`, '') AS `rank`, 
    COALESCE(mol.`abbrev`, '') AS `molecule` 
FROM 
    taxonomy_node tn
LEFT OUTER JOIN taxonomy_level `rank` ON `rank`.`id` = tn.`level_id`
LEFT OUTER JOIN taxonomy_molecule mol ON mol.`id` = tn.`molecule_id`
WHERE 
    tn.`msl_release_num` IS NOT NULL
    AND tn.`is_deleted` = 0
    AND (tn.`level_id` = 100 OR tn.`is_hidden` = 0)
    AND tn.`is_obsolete` = 0
ORDER BY 
    tn.`msl_release_num`, 
    tn.`left_idx`
--------------

Query OK, 0 rows affected (0.003 sec)

Bye
--------------
DROP VIEW IF EXISTS `taxonomy_node_x`
--------------

Query OK, 0 rows affected (0.005 sec)

--------------
CREATE VIEW `taxonomy_node_x` AS




SELECT 
    node.*, 
    target.`taxnode_id` AS target_taxnode_id,
    target.`name` AS target_name,
    target.`lineage` AS target_lineage
FROM 
    `taxonomy_node_names` target
JOIN 
    `taxonomy_node_merge_split` ms 
    ON target.`ictv_id` IN (ms.`prev_ictv_id`)
JOIN 
    `taxonomy_node_names` node 
    ON node.`ictv_id` IN (ms.`next_ictv_id`)
--------------

Query OK, 0 rows affected (0.008 sec)

Bye
--------------
DROP VIEW IF EXISTS `taxonomy_toc_dx`
--------------

Query OK, 0 rows affected (0.005 sec)

--------------
CREATE VIEW `taxonomy_toc_dx` AS
SELECT 
    t1.*, 
    (t1.`tree_id` - t2.`tree_id`) AS tree_id_delta,
    t2.`tree_id` AS prev_tree_id,
    t2.`msl_release_num` AS prev_msl
FROM 
    `taxonomy_toc` t1
JOIN 
    `taxonomy_toc` t2 
    ON t2.`msl_release_num` = t1.`msl_release_num` - 1
--------------

Query OK, 0 rows affected (0.006 sec)

Bye
--------------
DROP VIEW IF EXISTS `view_taxa_level_counts_by_release`
--------------

Query OK, 0 rows affected (0.005 sec)

--------------
CREATE VIEW `view_taxa_level_counts_by_release` AS

SELECT 
    `release`.tree_id, 
    `release`.notes,
    `release`.msl_release_num,
    `release`.name AS `year`,

    IFNULL(realm, 0) AS realms, 
    IFNULL(subrealm, 0) AS subrealms,
    IFNULL(kingdom, 0) AS kingdoms,
    IFNULL(subkingdom, 0) AS subkingdoms,
    IFNULL(phylum, 0) AS phyla,
    IFNULL(subphylum, 0) AS subphyla, 
    IFNULL(class, 0) AS classes,
    IFNULL(subclass, 0) AS subclasses,
    IFNULL(`order`, 0) AS orders,  
    IFNULL(suborder, 0) AS suborders,  
    IFNULL(family, 0) AS families,  
    IFNULL(subfamily, 0) AS subfamilies,  
    IFNULL(genus, 0) AS genera,  
    IFNULL(subgenus, 0) AS subgenera,  
    IFNULL(species, 0) AS species

FROM (
    SELECT 
        tree_id, 
        MAX(CASE WHEN name = 'realm' THEN count_by_level END) AS realm,
        MAX(CASE WHEN name = 'subrealm' THEN count_by_level END) AS subrealm,
        MAX(CASE WHEN name = 'kingdom' THEN count_by_level END) AS kingdom,
        MAX(CASE WHEN name = 'subkingdom' THEN count_by_level END) AS subkingdom,
        MAX(CASE WHEN name = 'phylum' THEN count_by_level END) AS phylum,
        MAX(CASE WHEN name = 'subphylum' THEN count_by_level END) AS subphylum,
        MAX(CASE WHEN name = 'class' THEN count_by_level END) AS class,
        MAX(CASE WHEN name = 'subclass' THEN count_by_level END) AS subclass,
        MAX(CASE WHEN name = 'order' THEN count_by_level END) AS `order`,
        MAX(CASE WHEN name = 'suborder' THEN count_by_level END) AS suborder,
        MAX(CASE WHEN name = 'family' THEN count_by_level END) AS family,
        MAX(CASE WHEN name = 'subfamily' THEN count_by_level END) AS subfamily,
        MAX(CASE WHEN name = 'genus' THEN count_by_level END) AS genus,
        MAX(CASE WHEN name = 'subgenus' THEN count_by_level END) AS subgenus,
        MAX(CASE WHEN name = 'species' THEN count_by_level END) AS species
    FROM (
        SELECT 
            COUNT(tn.level_id) AS count_by_level,
            tl.name,
            tn.tree_id
        FROM taxonomy_node tn
        JOIN taxonomy_level tl ON tl.id = tn.level_id
        WHERE tn.is_hidden = 0
        AND tn.msl_release_num IS NOT NULL
        AND tn.name NOT LIKE 'unassigned'
        GROUP BY tn.tree_id, tl.name
    ) AS levelCounts
    GROUP BY tree_id
) AS pivotedData
JOIN taxonomy_node `release` ON (`release`.tree_id = pivotedData.tree_id AND `release`.level_id = 100)
WHERE `release`.msl_release_num IS NOT NULL
AND `release`.name NOT LIKE 'unassigned'
--------------

Query OK, 0 rows affected (0.006 sec)

Bye
--------------
DROP VIEW IF EXISTS `view_taxonomy_stats`
--------------

Query OK, 0 rows affected (0.005 sec)

--------------
CREATE VIEW `view_taxonomy_stats` AS
SELECT 
    (SELECT notes
     FROM taxonomy_node AS t
     WHERE t.level_id = 100 AND t.taxnode_id = n.tree_id) AS notes, 
    n.msl_release_num,
    (SELECT name
     FROM taxonomy_node AS t
     WHERE t.level_id = 100 AND t.taxnode_id = n.tree_id) AS year, 
    COUNT(order_level.id) AS orders, 
    COUNT(family_level.id) AS families, 
    COUNT(subfamily_level.id) AS subfamilies, 
    COUNT(genus_level.id) AS genera, 
    COUNT(species_level.id) AS species
FROM 
    taxonomy_node AS n 
    LEFT JOIN taxonomy_level AS order_level ON order_level.id = n.level_id AND order_level.id = 200 
    LEFT JOIN taxonomy_level AS family_level ON family_level.id = n.level_id AND family_level.id = 300 
    LEFT JOIN taxonomy_level AS subfamily_level ON subfamily_level.id = n.level_id AND subfamily_level.id = 400 
    LEFT JOIN taxonomy_level AS genus_level ON genus_level.id = n.level_id AND genus_level.id = 500 
    LEFT JOIN taxonomy_level AS species_level ON species_level.id = n.level_id AND species_level.id = 600
WHERE 
    n.is_hidden = 0 
    AND n.msl_release_num IS NOT NULL 
    AND n.name NOT LIKE 'unassigned' 
    AND n.tree_id > 10090000
GROUP BY 
    n.tree_id, 
    n.msl_release_num
--------------

Query OK, 0 rows affected (0.006 sec)

Bye
--------------
DROP VIEW IF EXISTS `virus_isolates`
--------------

Query OK, 0 rows affected (0.005 sec)

--------------
CREATE VIEW `virus_isolates` AS
SELECT 
    si.species_name AS species, 
    si.isolate_type AS exemplar, 
    CASE WHEN isolate_type = 'E' THEN si.isolate_designation END AS exemplar_isolate, 
    CASE WHEN isolate_type = 'E' THEN si.genbank_accessions END AS exemplar_genbank_accession, 
    CASE WHEN isolate_type = 'E' THEN si.refseq_accessions END AS exemplar_refseq_accession, 
    CASE WHEN isolate_type = 'E' THEN si.genome_coverage END AS exemplar_seq_complete, 
    CASE WHEN isolate_type = 'A' THEN si.isolate_designation END AS isolate_csv, 
    CASE WHEN isolate_type = 'A' THEN si.genbank_accessions END AS isolate_genbank_accession_csv, 
    CASE WHEN isolate_type = 'A' THEN si.refseq_accessions END AS isolate_refseq_accession, 
    CASE WHEN isolate_type = 'A' THEN si.genome_coverage END AS isolate_seq_complete_csv, 
    si.isolate_names AS alternative_name_csv, 
    si.isolate_abbrevs AS abbrev_csv, 
    NULL AS isolate_abbrev, 
    si.species_sort AS sort_species, 
    si.isolate_sort AS sort, 
    si.taxnode_id AS taxnode_id, 
    si.host_source AS host, 
    si.molecule AS molecule, 
    tn.realm AS realm, 
    tn.subrealm AS subrealm, 
    tn.kingdom AS kingdom, 
    tn.subkingdom AS subkingdom, 
    tn.phylum AS phylum, 
    tn.subphylum AS subphylum, 
    tn.class AS class, 
    tn.subclass AS subclass, 
    tn.`order` AS `order`, 
    tn.suborder AS suborder, 
    tn.family AS family, 
    tn.subfamily AS subfamily, 
    tn.genus AS genus, 
    tn.subgenus AS subgenus, 
    tn.left_idx AS left_idx, 
    CASE WHEN si.molecule <> tn.inher_molecule THEN 'ERROR:molecule ' ELSE '' END AS qc_status, 
    tn.inher_molecule AS qc_taxon_inher_molecule, 
    si.update_change AS qc_taxon_change, 
    si.update_change_proposal AS qc_taxon_proposal
FROM species_isolates si
JOIN taxonomy_node_names tn ON tn.taxnode_id = si.taxnode_id
WHERE si.species_name <> 'abolished'
--------------

Query OK, 0 rows affected (0.007 sec)

Bye
--------------
CREATE OR REPLACE FUNCTION VMR_accessionsStripPrefixesAndConvertToCSV(
  inputString TEXT
)
RETURNS TEXT
DETERMINISTIC
NO SQL
SQL SECURITY INVOKER
BEGIN
  DECLARE s TEXT;
  DECLARE token TEXT;
  DECLARE outStr TEXT DEFAULT '';
  DECLARE sepPos INT;
  DECLARE colonPos INT;
  DECLARE parenPos INT;

  
  IF inputString IS NULL THEN
    RETURN '';
  END IF;

  
  SET s = REPLACE(inputString, ' ', '');

  
  loop_parts: LOOP
    SET sepPos = LOCATE(';', s);

    IF sepPos = 0 THEN
      
      SET token = s;
      SET s = '';  
    ELSE
      SET token = LEFT(s, sepPos - 1);
      SET s = SUBSTRING(s, sepPos + 1);
    END IF;

    
    SET colonPos = LOCATE(':', token);
    IF colonPos > 0 THEN
      SET token = SUBSTRING(token, colonPos + 1);
    END IF;

    
    SET parenPos = LOCATE('(', token);
    IF parenPos > 0 THEN
      SET token = LEFT(token, parenPos - 1);
    END IF;

    
    IF LENGTH(token) > 0 THEN
      SET outStr = CONCAT(outStr, token, ',');
    END IF;

    
    IF s = '' THEN
      LEAVE loop_parts;
    END IF;
  END LOOP loop_parts;

  
  IF outStr <> '' THEN
    SET outStr = LEFT(outStr, LENGTH(outStr) - 1);
  END IF;

  RETURN outStr;
END
--------------

Query OK, 0 rows affected (0.007 sec)

Bye
--------------
CREATE OR REPLACE VIEW `vmr_export` AS
SELECT
    CONCAT('=HYPERLINK("https://ictv.global/id/',
      'VMR', si.isolate_id,
      '","','VMR', si.isolate_id,'")')                        AS `Isolate ID`,
    si.species_sort                                           AS `Species Sort`,
    si.isolate_sort                                           AS `Isolate Sort`,
    tn.realm                                                  AS `Realm`,
    tn.subrealm                                               AS `Subrealm`,
    tn.kingdom                                                AS `Kingdom`,
    tn.subkingdom                                             AS `Subkingdom`,
    tn.phylum                                                 AS `Phylum`,
    tn.subphylum                                              AS `Subphylum`,
    tn.class                                                  AS `Class`,
    tn.subclass                                               AS `Subclass`,
    tn.`order`                                                AS `Order`,
    tn.suborder                                               AS `Suborder`,
    tn.family                                                 AS `Family`,
    tn.subfamily                                              AS `Subfamily`,
    tn.genus                                                  AS `Genus`,
    tn.subgenus                                               AS `Subgenus`,
    tn.species                                                AS `Species`, 
    
    CONCAT(
      '=HYPERLINK("https://ictv.global/id/',
      'ICTV', tn.ictv_id,
      '","','ICTV',tn.ictv_id,
      '")'
    )                                                         AS `ICTV_ID`,
    IFNULL(si.isolate_type, '')                               AS `Exemplar or additional isolate`,
    IFNULL(si.isolate_names, '')                              AS `Virus name(s)`,
    IFNULL(si.isolate_abbrevs, '')                            AS `Virus name abbreviation(s)`,
    IFNULL(si.isolate_designation, '')                        AS `Virus isolate designation`,
    IFNULL(si.genbank_accessions, '')                         AS `Virus GENBANK accession`,
    
    
    IFNULL(si.genome_coverage, '')                            AS `Genome coverage`,
    IFNULL(si.molecule, '')                                   AS `Genome`,
    IFNULL(si.host_source, '')                                AS `Host source`,
    CASE
      WHEN IFNULL(si.genbank_accessions,'') <> '' THEN
        CONCAT(
          '=HYPERLINK("https://www.ncbi.nlm.nih.gov/nuccore/',
          VMR_accessionsStripPrefixesAndConvertToCSV(si.genbank_accessions),
          '","NCBI Nucleotide")'
        )
      ELSE ''
    END                                                       AS `Accessions Link`,
    IFNULL(si.notes, '')                                      AS `Editor Notes`,
    
    CASE
      WHEN si.molecule <> tn.inher_molecule THEN 'ERROR:molecule '
      ELSE ''
    END                                                       AS `QC_status`,
    tn.inher_molecule                                         AS `QC_taxon_inher_molecule`,
    IFNULL(si.update_change,'')                               AS `QC_taxon_change`,
    IFNULL(
      CONCAT(
        '=HYPERLINK("https://ictv.global/ictv/proposals/',
        IFNULL(si.update_change_proposal,''),
        '","',
        REPLACE(IFNULL(si.update_change_proposal,''), '"', '""'),
        '")'
      ),
      ''
    )                                                         AS `QC_taxon_proposal`
FROM `species_isolates` AS si
JOIN `taxonomy_node_names` AS tn
  ON tn.taxnode_id = si.taxnode_id
WHERE tn.species <> 'abolished'
--------------

Query OK, 0 rows affected (0.009 sec)

Bye
--------------
CREATE OR REPLACE VIEW `QC_generate_taxonomy_history_binned_test_cases` AS
SELECT
  

  
  'TaxonomyHistory test case generator - one key ICTV_ID per connected ICTV‑merge‑split set' AS report,
  'v1.bin=family-subfamily-genus'                                                             AS report_version,

  
  msm.key_ictv_id,
  msm.ictv_ct,
  msm.key_taxnode_id,
  msm.txn_ct,

  
  CASE
    WHEN tnn.family = '' AND tnn.subfamily = '' AND tnn.genus = '' THEN 'Unassigned'
    WHEN tnn.family = '' AND tnn.subfamily = ''                    THEN REPLACE(tnn.genus     ,' ', '_')
    WHEN tnn.family = ''                                           THEN REPLACE(tnn.subfamily ,' ', '_')
    ELSE                                                                 REPLACE(tnn.family    ,' ', '_')
  END                                                               AS bin,

  
  REPLACE(
    CONCAT(
      'ICTV', msm.key_ictv_id, '=',
      tnn.`rank` COLLATE utf8mb4_bin, '=',
      REPLACE( REPLACE(tnn.lineage, ';', '='), ' ', '_' )
    ),
    '/', '_'
  ) AS key_taxon,

  
  'taxonomy'                                   AS unit_name,
  REPLACE(
    CONCAT('taxonomyHistoryRegression_', REPLACE(tnn.name, ' ', '_')),
    '/', '_'
  )                                            AS case_name,
  CONCAT(
    '/api/taxonomyHistory.ashx?action_code=get_taxon_history',
    '&current_release=40',
    '&taxnode_id=', msm.key_taxnode_id
  )                                            AS case_url

FROM taxonomy_node_names AS tnn
JOIN (
  
  SELECT
    ms.key_ictv_id,
    ms.ictv_ct,
    MIN(n.taxnode_id) AS key_taxnode_id,
    COUNT(*)          AS txn_ct
  FROM taxonomy_node AS n
  JOIN (
    SELECT
      key_ictv_id,
      COUNT(*) AS ictv_ct
    FROM (
      SELECT
        prev_ictv_id,
        MIN(next_ictv_id) AS key_ictv_id
      FROM taxonomy_node_merge_split
      GROUP BY prev_ictv_id
    ) AS src
    GROUP BY key_ictv_id
  ) AS ms
    ON ms.key_ictv_id = n.ictv_id
  GROUP BY ms.key_ictv_id, ms.ictv_ct
) AS msm
  ON msm.key_taxnode_id = tnn.taxnode_id
--------------

Query OK, 0 rows affected (0.009 sec)

Bye
--------------
CREATE INDEX idx_taxonomy_node_parent_level_tree ON taxonomy_node (parent_id, level_id, tree_id)
--------------

Query OK, 0 rows affected (1.052 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_taxonomy_node_taxnode_tree ON taxonomy_node (taxnode_id, tree_id)
--------------

Query OK, 0 rows affected (0.513 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_taxonomy_node_tree_level ON taxonomy_node (tree_id, level_id)
--------------

Query OK, 0 rows affected (0.797 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_node_hidden_msl_name_treelevel ON taxonomy_node (is_hidden, msl_release_num, name, tree_id, level_id)
--------------

Query OK, 0 rows affected (0.714 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_tn_name ON taxonomy_node (name)
--------------

Query OK, 0 rows affected (0.659 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_tn_name_mslrelease ON taxonomy_node (name, msl_release_num)
--------------

Query OK, 0 rows affected (0.765 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_tn_tree_id ON taxonomy_node (tree_id)
--------------

Query OK, 0 rows affected (0.604 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_tn_allreleases_order ON taxonomy_node (is_hidden, is_deleted, msl_release_num, left_idx)
--------------

Query OK, 0 rows affected (0.704 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_tn_sibling_order ON taxonomy_node (parent_id, level_id, left_idx, taxnode_id)
--------------

Query OK, 0 rows affected (0.692 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX abbrev ON taxonomy_molecule (abbrev)
--------------

Query OK, 0 rows affected (0.023 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX name ON taxonomy_genome_coverage (name)
--------------

Query OK, 0 rows affected (0.022 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX taxonomy_node_merge_split_next_ictv_id_IDX ON taxonomy_node_merge_split (next_ictv_id)
--------------

Query OK, 0 rows affected, 1 warning (0.130 sec)
Records: 0  Duplicates: 0  Warnings: 1

Note (Code 1831): Duplicate index `taxonomy_node_merge_split_next_ictv_id_IDX`. This is deprecated and will be disallowed in a future release
--------------
CREATE INDEX taxonomy_node_merge_split_prev_ictv_id_IDX ON taxonomy_node_merge_split (prev_ictv_id)
--------------

Query OK, 0 rows affected (0.056 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_taxonomy_node_delta_prev_taxid ON taxonomy_node_delta (prev_taxid)
--------------

Query OK, 0 rows affected (0.896 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_taxonomy_node_delta_new_taxid ON taxonomy_node_delta (new_taxid)
--------------

Query OK, 0 rows affected (0.191 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_taxonomy_json_taxnode_tree_ghost ON taxonomy_json (taxnode_id, tree_id, is_ghost_node)
--------------

Query OK, 0 rows affected (0.013 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_taxonomy_json_parent_taxnode_tree_ghost ON taxonomy_json (parent_taxnode_id, tree_id, is_ghost_node)
--------------

Query OK, 0 rows affected (0.016 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_taxonomy_json_id ON taxonomy_json (id)
--------------

Query OK, 0 rows affected (0.017 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_tj_tree_rank ON taxonomy_json (tree_id, rank_index)
--------------

Query OK, 0 rows affected (0.018 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_tj_tree_parent ON taxonomy_json (tree_id, parent_id)
--------------

Query OK, 0 rows affected (0.019 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_taxonomy_json_rank_level_tree ON taxonomy_json_rank (level_id, tree_id)
--------------

Query OK, 0 rows affected (0.021 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
CREATE INDEX idx_tjr_tree_rank ON taxonomy_json_rank (tree_id, rank_index)
--------------

Query OK, 0 rows affected (0.018 sec)
Records: 0  Duplicates: 0  Warnings: 0

Bye
--------------
ALTER TABLE `taxonomy_level`
  ADD CONSTRAINT `FK_taxonomy_level_taxonomy_level` 
  FOREIGN KEY (`parent_id`) REFERENCES `taxonomy_level` (`id`)
--------------

Query OK, 16 rows affected (0.028 sec)
Records: 16  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node_merge_split`
    ADD CONSTRAINT `FK_taxonomy_node_merge_split_taxonomy_node1` 
    FOREIGN KEY (`next_ictv_id`) 
    REFERENCES `taxonomy_node` (`taxnode_id`) 
    ON UPDATE CASCADE 
    ON DELETE CASCADE
--------------

Query OK, 38842 rows affected (0.761 sec)
Records: 38842  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `species_isolates` 
ADD CONSTRAINT `FK_species_isolates_taxonomy_genome_coverage` 
FOREIGN KEY (`genome_coverage`) 
REFERENCES `taxonomy_genome_coverage` (`name`)
--------------

Query OK, 18095 rows affected (0.327 sec)
Records: 18095  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `species_isolates` 
ADD CONSTRAINT `FK_species_isolates_taxonomy_host_source` 
FOREIGN KEY (`host_source`) 
REFERENCES `taxonomy_host_source` (`host_source`)
--------------

Query OK, 18095 rows affected (0.314 sec)
Records: 18095  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `species_isolates` 
ADD CONSTRAINT `FK_species_isolates_taxonomy_molecule` 
FOREIGN KEY (`molecule`) 
REFERENCES `taxonomy_molecule` (`abbrev`)
--------------

Query OK, 18095 rows affected (0.350 sec)
Records: 18095  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `species_isolates` 
ADD CONSTRAINT `FK_species_isolates_taxonomy_node` 
FOREIGN KEY (`taxnode_id`) 
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 18095 rows affected (0.405 sec)
Records: 18095  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `species_isolates` 
ADD CONSTRAINT `FK_species_isolates_taxonomy_update_prev_taxnode_id` 
FOREIGN KEY (`update_prev_taxnode_id`) 
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 18095 rows affected (0.412 sec)
Records: 18095  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_change_in`
FOREIGN KEY (`in_change`)
REFERENCES `taxonomy_change_in` (`change`)
--------------

Query OK, 172699 rows affected (8.483 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node` 
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_change_out` 
FOREIGN KEY (`out_change`) 
REFERENCES `taxonomy_change_out` (`change`)
--------------

Query OK, 172699 rows affected (10.440 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node` 
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_genome_coverage` 
FOREIGN KEY (`genome_coverage`) 
REFERENCES `taxonomy_genome_coverage` (`genome_coverage`)
--------------

Query OK, 172699 rows affected (10.837 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node` 
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_host_source` 
FOREIGN KEY (`host_source`) 
REFERENCES `taxonomy_host_source` (`host_source`)
--------------

Query OK, 172699 rows affected (10.955 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_level_level_id`
FOREIGN KEY (`level_id`)
REFERENCES `taxonomy_level` (`id`)
ON DELETE CASCADE
--------------

Query OK, 172699 rows affected (11.345 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_molecule_inher_molecule_id`
FOREIGN KEY (`inher_molecule_id`)
REFERENCES `taxonomy_molecule` (`id`)
--------------

Query OK, 172699 rows affected (11.839 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node` 
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_molecule_molecule_id` 
FOREIGN KEY (`molecule_id`) 
REFERENCES `taxonomy_molecule` (`id`)
--------------

Query OK, 172699 rows affected (11.986 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node` 
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_family_id` 
FOREIGN KEY (`family_id`) 
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (12.885 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node` 
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_genus_id` 
FOREIGN KEY (`genus_id`) 
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (13.491 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_ictv_id`
FOREIGN KEY (`ictv_id`)
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (13.675 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_order_id`
FOREIGN KEY (`order_id`)
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (13.460 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_species_id`
FOREIGN KEY (`species_id`)
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (14.176 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_subfamily_id`
FOREIGN KEY (`subfamily_id`)
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (14.199 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_tree_id`
FOREIGN KEY (`tree_id`)
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (14.294 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_class_id`
FOREIGN KEY (`class_id`)
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (14.480 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_kingdom_id`
FOREIGN KEY (`kingdom_id`)
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (14.676 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_phylum_id`
FOREIGN KEY (`phylum_id`)
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (14.993 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_realm_id`
FOREIGN KEY (`realm_id`)
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (15.241 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_subclass_id`
FOREIGN KEY (`subclass_id`)
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (15.397 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_subgenus_id`
FOREIGN KEY (`subgenus_id`)
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (15.751 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_subkingdom_id`
FOREIGN KEY (`subkingdom_id`)
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (15.813 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_suborder_id`
FOREIGN KEY (`suborder_id`)
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (15.977 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_subphylum_id`
FOREIGN KEY (`subphylum_id`)
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (16.469 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_node_subrealm_id`
FOREIGN KEY (`subrealm_id`)
REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 172699 rows affected (16.698 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_node`
ADD CONSTRAINT `FK_taxonomy_node_taxonomy_toc`
FOREIGN KEY (`tree_id`, `msl_release_num`)
REFERENCES `taxonomy_toc` (`tree_id`, `msl_release_num`)
--------------

Query OK, 172699 rows affected (16.836 sec)
Records: 172699  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_json_rank`
  ADD CONSTRAINT `FK_taxonomy_json_rank_taxonomy_level` 
  FOREIGN KEY (`level_id`) REFERENCES `taxonomy_level` (`id`)
--------------

Query OK, 0 rows affected (0.041 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_json_rank`
  ADD CONSTRAINT `FK_taxonomy_json_rank_tree_id` 
  FOREIGN KEY (`tree_id`) REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 0 rows affected (0.033 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_json`
  ADD CONSTRAINT `FK_taxonomy_json_parent_taxonomy_node` 
  FOREIGN KEY (`parent_taxnode_id`) REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 0 rows affected (0.039 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_json`
  ADD CONSTRAINT `FK_taxonomy_json_taxonomy_node` 
  FOREIGN KEY (`taxnode_id`) REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 0 rows affected (0.036 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
ALTER TABLE `taxonomy_json`
  ADD CONSTRAINT `FK_taxonomy_json_tree_id` 
  FOREIGN KEY (`tree_id`) REFERENCES `taxonomy_node` (`taxnode_id`)
--------------

Query OK, 0 rows affected (0.034 sec)
Records: 0  Duplicates: 0  Warnings: 0

Bye
--------------
DROP FUNCTION IF EXISTS count_accents
--------------

Query OK, 0 rows affected (0.009 sec)

--------------
CREATE FUNCTION count_accents(in_string VARCHAR(1000) CHARACTER SET utf8mb4)
RETURNS INT
DETERMINISTIC
BEGIN
    DECLARE cur_pos INT DEFAULT 1;
    DECLARE char_count INT DEFAULT 0;
    DECLARE str_length INT;

    SET str_length = CHAR_LENGTH(in_string);

    WHILE cur_pos <= str_length DO
        IF ORD(SUBSTRING(in_string, cur_pos, 1)) > 127 THEN
            SET char_count = char_count + 1;
        END IF;
        SET cur_pos = cur_pos + 1;
    END WHILE;

    RETURN char_count;
END
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP FUNCTION IF EXISTS udf_getChildTaxaCounts
--------------

Query OK, 0 rows affected (0.004 sec)

--------------
CREATE FUNCTION udf_getChildTaxaCounts(in_taxnode_id INT)
RETURNS VARCHAR(1000)
DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE result VARCHAR(1000);

    SELECT
        SUBSTRING(
            GROUP_CONCAT(cnt_name ORDER BY level_id SEPARATOR ''),
            3
        ) INTO result
    FROM (
        SELECT
            CONCAT(', ', CAST(COUNT(*) AS CHAR(6)), ' ', 
                   IF(COUNT(*) > 1, tl.plural, tl.name)) AS cnt_name,
            tn.level_id
        FROM taxonomy_node sub
        JOIN taxonomy_node tn ON tn.left_idx BETWEEN sub.left_idx AND sub.right_idx 
                               AND tn.tree_id = sub.tree_id
        JOIN taxonomy_level tl ON tl.id = tn.level_id
        WHERE sub.taxnode_id = in_taxnode_id
          AND tn.taxnode_id <> sub.taxnode_id
        GROUP BY tl.plural, tl.name, tn.level_id
    ) AS derived_table;

    RETURN IFNULL(result, '');
END
--------------

Query OK, 0 rows affected (0.007 sec)

Bye
--------------
DROP FUNCTION IF EXISTS udf_getMSL
--------------

Query OK, 0 rows affected (0.004 sec)

--------------
CREATE FUNCTION udf_getMSL(in_tree_id INT)
RETURNS INT
DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE msl INT;

    IF in_tree_id IS NULL THEN
        
        SELECT MAX(msl_release_num) INTO msl FROM taxonomy_toc;
        RETURN msl;
    ELSE
        
        SELECT msl_release_num INTO msl
        FROM taxonomy_toc
        WHERE tree_id = in_tree_id
        ORDER BY msl_release_num DESC
        LIMIT 1;

        RETURN msl;
    END IF;
END
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP FUNCTION IF EXISTS udf_getTaxNodeChildInfo
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE FUNCTION udf_getTaxNodeChildInfo(
    in_taxnode_id INT
)
RETURNS VARCHAR(512)
DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE child_info_result VARCHAR(512);
    DECLARE invalid_result_count INT DEFAULT 0;

    
    SELECT
        COUNT(*) INTO invalid_result_count
    FROM (
        SELECT level_id, level_count,
               udf_singularOrPluralTaxLevelNames(level_count, level_id) AS result_label
        FROM (
            SELECT level_id, COUNT(DISTINCT taxnode_id) AS level_count
            FROM (
                
                SELECT tn3.level_id AS level_id, tn3.taxnode_id
                FROM taxonomy_node tn2
                JOIN taxonomy_node tn3 ON tn3.parent_id = tn2.taxnode_id
                WHERE tn2.parent_id = in_taxnode_id
                    AND tn2.is_hidden = 1
                    AND tn2.is_deleted = 0
                    AND tn3.is_deleted = 0
                    AND tn3.name <> 'unassigned'

                UNION ALL

                SELECT tn1.level_id AS level_id, tn1.taxnode_id
                FROM taxonomy_node tn1
                WHERE tn1.parent_id = in_taxnode_id
                    AND tn1.parent_id <> tn1.taxnode_id
                    AND tn1.is_hidden = 0
                    AND tn1.is_deleted = 0
            ) AS combined
            GROUP BY level_id
        ) AS level_counts
        WHERE udf_singularOrPluralTaxLevelNames(level_count, level_id) IS NULL
            OR udf_singularOrPluralTaxLevelNames(level_count, level_id) = ''
    ) AS invalid_results;

    
    IF invalid_result_count > 0 THEN
        RETURN NULL;
    ELSE
        
        SELECT GROUP_CONCAT(result_label ORDER BY level_id ASC SEPARATOR ', ') INTO child_info_result
        FROM (
            SELECT level_id, level_count,
                   udf_singularOrPluralTaxLevelNames(level_count, level_id) AS result_label
            FROM (
                SELECT level_id, COUNT(DISTINCT taxnode_id) AS level_count
                FROM (
                    
                    SELECT tn3.level_id AS level_id, tn3.taxnode_id
                    FROM taxonomy_node tn2
                    JOIN taxonomy_node tn3 ON tn3.parent_id = tn2.taxnode_id
                    WHERE tn2.parent_id = in_taxnode_id
                        AND tn2.is_hidden = 1
                        AND tn2.is_deleted = 0
                        AND tn3.is_deleted = 0
                        AND tn3.name <> 'unassigned'

                    UNION ALL

                    SELECT tn1.level_id AS level_id, tn1.taxnode_id
                    FROM taxonomy_node tn1
                    WHERE tn1.parent_id = in_taxnode_id
                        AND tn1.parent_id <> tn1.taxnode_id
                        AND tn1.is_hidden = 0
                        AND tn1.is_deleted = 0
                ) AS combined
                GROUP BY level_id
            ) AS level_counts
            WHERE udf_singularOrPluralTaxLevelNames(level_count, level_id) IS NOT NULL
                AND udf_singularOrPluralTaxLevelNames(level_count, level_id) <> ''
        ) AS valid_results;

        RETURN child_info_result;
    END IF;
END
--------------

Query OK, 0 rows affected (0.006 sec)

Bye
--------------
DROP FUNCTION IF EXISTS udf_getTreeID
--------------

Query OK, 0 rows affected (0.004 sec)

--------------
CREATE FUNCTION udf_getTreeID(in_msl INT)
RETURNS INT
DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE v_tree_id INT;

    IF in_msl IS NULL THEN
        
        SELECT MAX(tree_id) INTO v_tree_id FROM taxonomy_toc;
        RETURN v_tree_id;
    ELSE
        
        SELECT tree_id INTO v_tree_id
        FROM taxonomy_toc
        WHERE msl_release_num IS NOT NULL
          AND msl_release_num = in_msl
        ORDER BY msl_release_num
        LIMIT 1;

        RETURN v_tree_id;
    END IF;
END
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP FUNCTION IF EXISTS udf_rankCountsToStringWithPurals
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE FUNCTION udf_rankCountsToStringWithPurals(
    realm_ct INT,
    subrealm_ct INT,
    kingdom_ct INT,
    subkingdom_ct INT,

    phylum_ct INT,
    subphylum_ct INT,
    class_ct INT,
    subclass_ct INT,

    order_ct INT,
    suborder_ct INT,
    family_ct INT,
    subfamily_ct INT,

    genus_ct INT,
    subgenus_ct INT,

    species_ct INT
)
RETURNS VARCHAR(1000)
DETERMINISTIC
BEGIN
    DECLARE csv VARCHAR(1000);
    DECLARE str VARCHAR(100);

    
    SET str = CASE realm_ct
        WHEN 0 THEN NULL
        WHEN 1 THEN '1 realm'
        ELSE CONCAT(realm_ct, ' realms')
    END;

    IF str IS NOT NULL THEN
        SET csv = str;
    ELSE
        SET csv = NULL;
    END IF;

    
    SET str = CASE subrealm_ct
        WHEN 0 THEN NULL
        WHEN 1 THEN '1 subrealm'
        ELSE CONCAT(subrealm_ct, ' subrealms')
    END;

    IF str IS NOT NULL THEN
        IF csv IS NOT NULL THEN
            SET csv = CONCAT(csv, ', ', str);
        ELSE
            SET csv = str;
        END IF;
    END IF;

    
    SET str = CASE kingdom_ct
        WHEN 0 THEN NULL
        WHEN 1 THEN '1 kingdom'
        ELSE CONCAT(kingdom_ct, ' kingdoms')
    END;

    IF str IS NOT NULL THEN
        IF csv IS NOT NULL THEN
            SET csv = CONCAT(csv, ', ', str);
        ELSE
            SET csv = str;
        END IF;
    END IF;

    
    SET str = CASE subkingdom_ct
        WHEN 0 THEN NULL
        WHEN 1 THEN '1 subkingdom'
        ELSE CONCAT(subkingdom_ct, ' subkingdoms')
    END;

    IF str IS NOT NULL THEN
        IF csv IS NOT NULL THEN
            SET csv = CONCAT(csv, ', ', str);
        ELSE
            SET csv = str;
        END IF;
    END IF;

    
    SET str = CASE phylum_ct
        WHEN 0 THEN NULL
        WHEN 1 THEN '1 phylum'
        ELSE CONCAT(phylum_ct, ' phyla')  
    END;

    IF str IS NOT NULL THEN
        IF csv IS NOT NULL THEN
            SET csv = CONCAT(csv, ', ', str);
        ELSE
            SET csv = str;
        END IF;
    END IF;

    
    SET str = CASE subphylum_ct
        WHEN 0 THEN NULL
        WHEN 1 THEN '1 subphylum'
        ELSE CONCAT(subphylum_ct, ' subphyla')  
    END;

    IF str IS NOT NULL THEN
        IF csv IS NOT NULL THEN
            SET csv = CONCAT(csv, ', ', str);
        ELSE
            SET csv = str;
        END IF;
    END IF;

    
    SET str = CASE class_ct
        WHEN 0 THEN NULL
        WHEN 1 THEN '1 class'
        ELSE CONCAT(class_ct, ' classes')
    END;

    IF str IS NOT NULL THEN
        IF csv IS NOT NULL THEN
            SET csv = CONCAT(csv, ', ', str);
        ELSE
            SET csv = str;
        END IF;
    END IF;

    
    SET str = CASE subclass_ct
        WHEN 0 THEN NULL
        WHEN 1 THEN '1 subclass'
        ELSE CONCAT(subclass_ct, ' subclasses')
    END;

    IF str IS NOT NULL THEN
        IF csv IS NOT NULL THEN
            SET csv = CONCAT(csv, ', ', str);
        ELSE
            SET csv = str;
        END IF;
    END IF;

    
    SET str = CASE order_ct
        WHEN 0 THEN NULL
        WHEN 1 THEN '1 order'
        ELSE CONCAT(order_ct, ' orders')
    END;

    IF str IS NOT NULL THEN
        IF csv IS NOT NULL THEN
            SET csv = CONCAT(csv, ', ', str);
        ELSE
            SET csv = str;
        END IF;
    END IF;

    
    SET str = CASE suborder_ct
        WHEN 0 THEN NULL
        WHEN 1 THEN '1 suborder'
        ELSE CONCAT(suborder_ct, ' suborders')
    END;

    IF str IS NOT NULL THEN
        IF csv IS NOT NULL THEN
            SET csv = CONCAT(csv, ', ', str);
        ELSE
            SET csv = str;
        END IF;
    END IF;

    
    SET str = CASE family_ct
        WHEN 0 THEN NULL
        WHEN 1 THEN '1 family'
        ELSE CONCAT(family_ct, ' families')  
    END;

    IF str IS NOT NULL THEN
        IF csv IS NOT NULL THEN
            SET csv = CONCAT(csv, ', ', str);
        ELSE
            SET csv = str;
        END IF;
    END IF;

    
    SET str = CASE subfamily_ct
        WHEN 0 THEN NULL
        WHEN 1 THEN '1 subfamily'
        ELSE CONCAT(subfamily_ct, ' subfamilies')  
    END;

    IF str IS NOT NULL THEN
        IF csv IS NOT NULL THEN
            SET csv = CONCAT(csv, ', ', str);
        ELSE
            SET csv = str;
        END IF;
    END IF;

    
    SET str = CASE genus_ct
        WHEN 0 THEN NULL
        WHEN 1 THEN '1 genus'
        ELSE CONCAT(genus_ct, ' genera')  
    END;

    IF str IS NOT NULL THEN
        IF csv IS NOT NULL THEN
            SET csv = CONCAT(csv, ', ', str);
        ELSE
            SET csv = str;
        END IF;
    END IF;

    
    SET str = CASE subgenus_ct
        WHEN 0 THEN NULL
        WHEN 1 THEN '1 subgenus'
        ELSE CONCAT(subgenus_ct, ' subgenera')  
    END;

    IF str IS NOT NULL THEN
        IF csv IS NOT NULL THEN
            SET csv = CONCAT(csv, ', ', str);
        ELSE
            SET csv = str;
        END IF;
    END IF;

    
    SET str = CASE species_ct
        WHEN 0 THEN NULL
        WHEN 1 THEN '1 species'
        ELSE CONCAT(species_ct, ' species')  
    END;

    IF str IS NOT NULL THEN
        IF csv IS NOT NULL THEN
            SET csv = CONCAT(csv, ', ', str);
        ELSE
            SET csv = str;
        END IF;
    END IF;

    
    RETURN IFNULL(csv, '');
END
--------------

Query OK, 0 rows affected (0.007 sec)

Bye
--------------
DROP FUNCTION IF EXISTS udf_singularOrPluralTaxLevelNames
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE FUNCTION udf_singularOrPluralTaxLevelNames(
    level_count INT,
    level_id INT
)
RETURNS VARCHAR(128)
DETERMINISTIC
BEGIN
    DECLARE level_label VARCHAR(128) DEFAULT '';
    DECLARE result VARCHAR(200) DEFAULT '';

    
    SET level_label = CASE
        WHEN level_id = 200 AND level_count = 1 THEN 'Order'
        WHEN level_id = 200 AND level_count <> 1 THEN 'Orders'

        WHEN level_id = 300 AND level_count = 1 THEN 'Family'
        WHEN level_id = 300 AND level_count <> 1 THEN 'Families'

        WHEN level_id = 400 AND level_count = 1 THEN 'Subfamily'
        WHEN level_id = 400 AND level_count <> 1 THEN 'Subfamilies'

        WHEN level_id = 500 AND level_count = 1 THEN 'Genus'
        WHEN level_id = 500 AND level_count <> 1 THEN 'Genera'

        WHEN level_id = 600 THEN 'Species'

        ELSE ''
    END;

    
    SET level_label = IFNULL(level_label, '');

    
    IF level_label <> '' THEN
        SET result = CONCAT(CAST(level_count AS CHAR(3)), ' ', level_label);
    END IF;

    
    RETURN result;
END
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP FUNCTION IF EXISTS vgd_strrchr
--------------

Query OK, 0 rows affected (0.004 sec)

--------------
CREATE FUNCTION vgd_strrchr(
    targets VARBINARY(255), 
    str VARBINARY(255)      
)
RETURNS INT
DETERMINISTIC
BEGIN
    DECLARE cur_pos INT DEFAULT LENGTH(str);
    DECLARE c VARBINARY(1);
    IF str IS NULL OR targets IS NULL THEN
        RETURN 0;
    END IF;
    WHILE cur_pos > 0 DO
        SET c = SUBSTRING(str, cur_pos, 1);
        
        IF LOCATE(c, targets) > 0 THEN
            RETURN cur_pos;
        END IF;
        SET cur_pos = cur_pos - 1;
    END WHILE;
    RETURN 0;
END
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS createParentGhostNodes
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE createParentGhostNodes(
    IN treeID INT
)
BEGIN
    
    DECLARE errorCode INT DEFAULT 50000;
    DECLARE treeJsonID INT;
    DECLARE lowestRankToCreate INT;
    DECLARE currentRankIndex INT DEFAULT 1;
    DECLARE previousID INT;
    DECLARE tj_id INT;         
    DECLARE parentID INT;
    DECLARE done INT DEFAULT 0;

    
    DECLARE top_level_cursor CURSOR FOR
        SELECT
            notghost.id,
            (
                SELECT id
                FROM taxonomy_json ghost
                WHERE ghost.is_ghost_node = 1
                    AND ghost.source = 'P'             
                    AND ghost.rank_index = notghost.rank_index - 1
                    AND ghost.parent_taxnode_id = treeID
                    AND ghost.tree_id = treeID
                LIMIT 1
            ) AS parentID
        FROM taxonomy_json notghost
        WHERE notghost.parent_taxnode_id = treeID     
            AND notghost.taxnode_id <> treeID         
            AND notghost.is_ghost_node = 0            
            AND notghost.rank_index > 1               
            AND notghost.tree_id = treeID;

    
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        
        DECLARE err_msg TEXT;
        DECLARE err_code INT;
        GET DIAGNOSTICS CONDITION 1
            err_code = MYSQL_ERRNO,
            err_msg = MESSAGE_TEXT;
        
        ROLLBACK;
        
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = err_msg;
    END;

    
    START TRANSACTION;

    
    
    
    SELECT id INTO treeJsonID
    FROM taxonomy_json tj
    WHERE tj.tree_id = treeID
        AND tj.rank_index = 0
    LIMIT 1;

    IF treeJsonID IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Invalid taxonomy_json.id for tree node';
    END IF;

    
    SELECT MAX(rank_index) - 1 INTO lowestRankToCreate
    FROM taxonomy_json
    WHERE parent_taxnode_id = treeID      
        AND taxnode_id <> treeID          
        AND tree_id = treeID              
        AND is_ghost_node = 0             
        AND rank_index > 1                
        AND rank_index IS NOT NULL;       

    IF lowestRankToCreate IS NULL THEN
        SET lowestRankToCreate = 0;
    END IF;

    SET previousID = treeJsonID;

    
    
    
    WHILE currentRankIndex <= lowestRankToCreate DO

        
        INSERT INTO taxonomy_json (
            is_ghost_node,
            parent_distance,
            parent_taxnode_id,
            parent_id,
            rank_index,
            source,
            taxnode_id,
            tree_id
        ) VALUES (
            1,              
            1,              
            treeID,
            previousID,
            currentRankIndex,
            'P',            
            NULL,
            treeID
        );

        
        SET previousID = LAST_INSERT_ID();

        SET currentRankIndex = currentRankIndex + 1;
    END WHILE;

    
    
    
    
    OPEN top_level_cursor;

    
    read_loop: LOOP
        FETCH top_level_cursor INTO tj_id, parentID;  
        IF done = 1 THEN
            LEAVE read_loop;
        END IF;

        
        UPDATE taxonomy_json
        SET parent_id = parentID
        WHERE `id` = tj_id;  

    END LOOP;

    
    CLOSE top_level_cursor;

    
    COMMIT;

END
--------------

Query OK, 0 rows affected (0.006 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS createIntermediateGhostNodes
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE createIntermediateGhostNodes(
    IN childCounts VARCHAR(1000),
    IN parentID INT,
    IN parentRankIndex INT,
    IN parentTaxnodeID INT,
    IN speciesRankIndex INT,
    IN treeID INT
)
BEGIN
    
    DECLARE errorCode INT DEFAULT 50000;
    DECLARE maxChildRankIndex INT;
    DECLARE currentRankIndex INT;
    DECLARE currentID INT;
    DECLARE previousID INT;
    DECLARE childID INT;
    DECLARE childRankIndex INT;
    DECLARE childTaxnodeID INT;
    DECLARE done INT DEFAULT 0;

    
    DECLARE child_cursor CURSOR FOR
        SELECT 
            id,
            rank_index,
            taxnode_id
        FROM taxonomy_json tj
        WHERE tj.parent_taxnode_id = parentTaxnodeID
            AND tj.is_ghost_node = 0
            AND tj.rank_index > parentRankIndex + 1
        ORDER BY tj.rank_index ASC;

    
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        
        DECLARE err_msg TEXT;
        DECLARE err_code INT;
        GET DIAGNOSTICS CONDITION 1
            err_code = MYSQL_ERRNO,
            err_msg = MESSAGE_TEXT;
        
        ROLLBACK;
        
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = err_msg;
    END;

    
    IF childCounts IS NULL THEN
        SET childCounts = '';
    END IF;

    
    START TRANSACTION;

    
    
    
    SELECT MAX(rank_index) INTO maxChildRankIndex
    FROM taxonomy_json tj
    WHERE tj.parent_taxnode_id = parentTaxnodeID
        AND tj.is_ghost_node = 0
        AND tj.rank_index <= speciesRankIndex
        AND tj.rank_index > parentRankIndex + 1;

    
    IF maxChildRankIndex IS NOT NULL THEN

        
        SET currentRankIndex = parentRankIndex + 1;
        SET previousID = parentID;

        
        
        
        WHILE currentRankIndex < maxChildRankIndex DO

            INSERT INTO taxonomy_json (
                child_counts,
                is_ghost_node,
                parent_distance,
                parent_id,
                parent_taxnode_id,
                rank_index,
                source,
                taxnode_id,
                tree_id
            ) VALUES (
                childCounts,
                1,              
                1,              
                previousID,
                parentTaxnodeID,
                currentRankIndex,
                'I',            
                NULL,
                treeID
            );

            
            SET currentID = LAST_INSERT_ID();
            SET previousID = currentID;

            SET currentRankIndex = currentRankIndex + 1;
        END WHILE;

        
        OPEN child_cursor;

        
        read_loop: LOOP
            FETCH child_cursor INTO childID, childRankIndex, childTaxnodeID;
            IF done = 1 THEN
                LEAVE read_loop;
            END IF;

            
            
            
            UPDATE taxonomy_json
            SET parent_id = (
                SELECT id
                FROM taxonomy_json
                WHERE parent_taxnode_id = parentTaxnodeID
                    AND is_ghost_node = 1
                    AND rank_index = childRankIndex - 1
                    AND tree_id = treeID
                LIMIT 1
            )
            WHERE id = childID;

        END LOOP;

        
        CLOSE child_cursor;

    END IF;

    
    COMMIT;

END
--------------

Query OK, 0 rows affected (0.006 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS createGhostNodes
--------------

Query OK, 0 rows affected (0.004 sec)

--------------
CREATE PROCEDURE createGhostNodes(
    IN speciesRankIndex INT,
    IN treeID INT
)
BEGIN
    
    DECLARE childCounts VARCHAR(1000);
    DECLARE tj_id INT;         
    DECLARE rankIndex INT;
    DECLARE taxNodeID INT;
    DECLARE done BOOL DEFAULT FALSE;

    
    DECLARE taxon_cursor CURSOR FOR
        SELECT
            child_counts,
            id,
            rank_index,
            taxnode_id
        FROM taxonomy_json tj
        WHERE tj.tree_id = treeID
            AND tj.is_ghost_node = 0
            AND tj.rank_index < speciesRankIndex
            AND tj.taxnode_id <> treeID
        ORDER BY tj.rank_index ASC;

    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        
        DECLARE err_msg TEXT;
        DECLARE err_code INT;
        GET DIAGNOSTICS CONDITION 1
            err_code = MYSQL_ERRNO,
            err_msg = MESSAGE_TEXT;
        
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = err_msg;
    END;

    

    
    CALL createParentGhostNodes(treeID);

    
    OPEN taxon_cursor;

    
    read_loop: LOOP
        FETCH taxon_cursor INTO childCounts, tj_id, rankIndex, taxNodeID;  
        IF done THEN
            LEAVE read_loop;
        END IF;

        
        CALL createIntermediateGhostNodes(
            childCounts,
            tj_id,            
            rankIndex,
            taxNodeID,
            speciesRankIndex,
            treeID
        );
    END LOOP;

    
    CLOSE taxon_cursor;

END
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS initializeJsonColumn
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE initializeJsonColumn(IN treeID INT)
BEGIN

    
    DECLARE current_id INT;
    DECLARE rankIndex INT;
    DECLARE taxNodeID INT;
    DECLARE childJSON LONGTEXT;
    DECLARE done INT DEFAULT 0;
    DECLARE group_concat_max_len_value INT;

    
    DECLARE ranked_node_cursor CURSOR FOR
        SELECT 
            tj.id,
            tj.rank_index,
            tj.taxnode_id
        FROM taxonomy_json tj
        WHERE tj.tree_id = treeID
        ORDER BY tj.rank_index DESC;

    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    
    SET SESSION group_concat_max_len = 10000000;

    
    
    
    
    
    

    
    
    
    UPDATE taxonomy_json tj
    JOIN taxonomy_json_rank tr ON (
        tr.rank_index = tj.rank_index
        AND tr.tree_id = treeID
    )
    LEFT JOIN taxonomy_node tn ON tn.taxnode_id = tj.taxnode_id
    SET tj.json = CONCAT(
        '"child_counts":', CASE
            WHEN tj.child_counts IS NULL OR CHAR_LENGTH(tj.child_counts) < 1 THEN 'null' ELSE CONCAT('"', tj.child_counts, '"')
        END, ',',
        '"has_assigned_siblings":', CASE
            WHEN IFNULL(tj.has_assigned_siblings, 0) = 0 THEN 'false' ELSE 'true'
        END, ',',
        '"has_species":', CAST(IFNULL(tj.has_species, 0) AS CHAR), ',',
        '"is_assigned":', CASE
            WHEN tj.is_ghost_node = 1 THEN 'false' ELSE 'true'
        END, ',',
        '"has_unassigned_siblings":', CASE
            WHEN IFNULL(tj.has_unassigned_siblings, 0) = 0 THEN 'false' ELSE 'true'
        END, ',',
        
        
        
        '"name":', CASE
            WHEN tn.name IS NULL THEN '"Unassigned"' ELSE CONCAT('"', tn.name, '"')
        END, ',',
        '"parentDistance":', CAST(IFNULL(tj.parent_distance, 1) AS CHAR), ',',
        '"parentTaxNodeID":', CASE
            WHEN tj.parent_taxnode_id IS NULL THEN 'null' ELSE CAST(tj.parent_taxnode_id AS CHAR(12))
        END, ',',
        '"rankIndex":', CAST(tj.rank_index AS CHAR), ',',
        '"rankName":"', tr.rank_name, '",',
        '"taxNodeID":', CASE
            WHEN tj.taxnode_id IS NULL THEN 'null' ELSE CAST(tj.taxnode_id AS CHAR(12))
        END, ','
    )
    WHERE tj.tree_id = treeID;

    
    
    
    OPEN ranked_node_cursor;
    read_loop: LOOP
        FETCH ranked_node_cursor INTO current_id, rankIndex, taxNodeID;
        IF done = 1 THEN
            LEAVE read_loop;
        END IF;

        
        SELECT GROUP_CONCAT(nodeJSON ORDER BY rank_index ASC, is_ghost_node ASC, node_name ASC SEPARATOR ',') INTO childJSON
        FROM (
            SELECT 
                CONCAT(
                    '{',
                    tj.json,
                    '"children":', CASE
                        WHEN tj.child_json IS NULL OR CHAR_LENGTH(tj.child_json) < 1 THEN 'null' ELSE CONCAT('[', tj.child_json, ']')
                    END,
                    '}'
                ) AS nodeJSON,
                tj.rank_index,
                tj.is_ghost_node,
                tn.name AS node_name
            FROM taxonomy_json tj
            LEFT JOIN taxonomy_node tn ON tn.taxnode_id = tj.taxnode_id
            WHERE tj.parent_id = current_id
              AND tj.tree_id = treeID
        ) childJSON_table;

        
        UPDATE taxonomy_json SET child_json = childJSON WHERE id = current_id;

    END LOOP read_loop;

    CLOSE ranked_node_cursor;

END
--------------

Query OK, 0 rows affected (0.006 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS initializeTaxonomyJsonFromTaxonomyNode
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE initializeTaxonomyJsonFromTaxonomyNode(IN treeID INT)
BEGIN
    
    DECLARE speciesLevelID INT;
    DECLARE errorMsg VARCHAR(200);
    DECLARE errorCode INT DEFAULT 50000;

    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 errorMsg = MESSAGE_TEXT;
        
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = errorMsg;
    END;

    
    
    
    SELECT id INTO speciesLevelID
    FROM taxonomy_level
    WHERE name = 'species'
    LIMIT 1;

    IF speciesLevelID IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Invalid level_id for species';
    END IF;

    
    
    
    INSERT INTO taxonomy_json (
        child_counts,
        child_json,
        has_species,
        is_ghost_node,
        json,
        parent_distance,
        parent_id,
        parent_taxnode_id,
        rank_index,
        source,
        taxnode_id,
        tree_id
    )
    SELECT
        IFNULL(child_counts, '') AS child_counts,
        NULL AS child_json,
        has_species,
        0 AS is_ghost_node,
        NULL AS json,
        rank_index - IFNULL(parent_rank_index, 0) AS parent_distance,
        NULL AS parent_id,
        parent_taxnode_id,
        rank_index,
        'T' AS source,
        taxnode_id,
        tree_id
    FROM (
        SELECT
            tn.taxa_desc_cts AS child_counts,
            CASE
                WHEN 0 < (
                    SELECT COUNT(*)
                    FROM taxonomy_node species
                    WHERE species.parent_id = tn.taxnode_id
                      AND species.level_id = speciesLevelID
                      AND species.tree_id = treeID
                ) THEN 1 ELSE 0
            END AS has_species,
            parentRank.rank_index AS parent_rank_index,
            tn.parent_id AS parent_taxnode_id,
            tr.rank_index AS rank_index,
            tn.taxnode_id,
            tn.tree_id
        FROM taxonomy_node tn
        JOIN taxonomy_json_rank tr ON (
            tr.level_id = tn.level_id
            AND tr.tree_id = treeID
        )
        LEFT JOIN taxonomy_node parentTN ON (
            parentTN.taxnode_id = tn.parent_id
            AND parentTN.tree_id = treeID
        )
        LEFT JOIN taxonomy_json_rank parentRank ON (
            parentRank.level_id = parentTN.level_id
            AND parentRank.tree_id = treeID
        )
        WHERE tn.tree_id = treeID
    ) taxa;

    
    
    
    UPDATE taxonomy_json tj
    JOIN taxonomy_json parent_tj ON parent_tj.taxnode_id = tj.parent_taxnode_id
    SET tj.parent_id = parent_tj.id
    WHERE tj.tree_id = treeID
      AND parent_tj.tree_id = treeID
      AND tj.is_ghost_node = 0
      AND parent_tj.is_ghost_node = 0;

    
    

END
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS populateTaxonomyJSON
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE populateTaxonomyJSON(IN treeID INT)
BEGIN
    
    DECLARE errorCode INT DEFAULT 50000;
    DECLARE speciesRankIndex INT;
    DECLARE errorMsg VARCHAR(200);

    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 errorMsg = MESSAGE_TEXT;
        
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = errorMsg;
    END;

    
    
    
    DELETE FROM taxonomy_json WHERE tree_id = treeID;

    
    
    
    SELECT rank_index INTO speciesRankIndex
    FROM taxonomy_json_rank
    WHERE rank_name = 'species'
      AND tree_id = treeID
    LIMIT 1;

    IF speciesRankIndex IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Invalid species rank index';
    END IF;

    
    
    
    CALL initializeTaxonomyJSONFromTaxonomyNode(treeID);

    
    
    
    CALL createGhostNodes(speciesRankIndex, treeID);

    
    
    
    UPDATE taxonomy_json tj
    SET 
        has_assigned_siblings = CASE
            WHEN (
                SELECT COUNT(*)
                FROM taxonomy_json assigned
                WHERE assigned.tree_id = treeID
                  AND assigned.parent_id = tj.parent_id
                  AND assigned.is_ghost_node = 0
                  AND assigned.id <> tj.id
                  AND assigned.rank_index = tj.rank_index
            ) = 0 THEN 0 ELSE 1
        END,
        has_unassigned_siblings = CASE
            WHEN (
                SELECT COUNT(*)
                FROM taxonomy_json unassigned
                WHERE unassigned.tree_id = treeID
                  AND unassigned.parent_id = tj.parent_id
                  AND unassigned.is_ghost_node = 1
                  AND unassigned.id <> tj.id
                  AND unassigned.rank_index = tj.rank_index
            ) = 0 THEN 0 ELSE 1
        END
    WHERE tj.tree_id = treeID;

    
    
    
    UPDATE taxonomy_json ghostNode
    SET has_species = CASE
        WHEN (
            SELECT COUNT(*)
            FROM taxonomy_json ctj
            WHERE ctj.parent_id = ghostNode.id
              AND ctj.rank_index = speciesRankIndex
              AND ctj.tree_id = treeID
        ) > 0 THEN 1 ELSE 0
    END
    WHERE ghostNode.tree_id = treeID
      AND ghostNode.is_ghost_node = 1;

    
    
    
    

    
    
    
    CALL initializeJsonColumn(treeID);

END
--------------

Query OK, 0 rows affected (0.006 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS populateTaxonomyJsonForAllReleases
--------------

Query OK, 0 rows affected (0.004 sec)

--------------
CREATE PROCEDURE populateTaxonomyJsonForAllReleases()
BEGIN
    
    DECLARE errorCode INT DEFAULT 50000;
    DECLARE errorMsg VARCHAR(200);
    DECLARE treeID INT;
    DECLARE done INT DEFAULT FALSE;

    
    DECLARE release_cursor CURSOR FOR
        SELECT tree_id 
        FROM taxonomy_toc 
        WHERE msl_release_num IS NOT NULL
        ORDER BY tree_id;

    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 errorMsg = MESSAGE_TEXT;
        
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = errorMsg;
    END;

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    
    
    
    IF (SELECT COUNT(*) FROM taxonomy_json_rank) < 1 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'No taxonomy JSON ranks exist. Run the stored procedure initializeTaxonomyJsonRanks and try again.';
    END IF;

    
    
    
    OPEN release_cursor;

    
    read_loop: LOOP
        FETCH release_cursor INTO treeID;
        IF done THEN
            LEAVE read_loop;
        END IF;

        
        CALL populateTaxonomyJSON(treeID);
    END LOOP;

    
    CLOSE release_cursor;

END
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS exportReleasesJSON
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE exportReleasesJSON()
BEGIN
    
    DECLARE dataJSON LONGTEXT DEFAULT '';
    DECLARE displayOrderJSON LONGTEXT DEFAULT '';
    DECLARE finalJSON LONGTEXT DEFAULT '';
    DECLARE mslReleaseNum INT;
    DECLARE rankCount INT;
    DECLARE yearAB VARCHAR(10);
    DECLARE done INT DEFAULT 0;

    
    DECLARE releaseCursor CURSOR FOR
        SELECT
            toc.msl_release_num,
            (
                SELECT COUNT(DISTINCT tnRank.level_id)
                FROM taxonomy_node tnRank
                WHERE tnRank.tree_id = toc.tree_id
                AND tnRank.level_id <> (SELECT id FROM taxonomy_level WHERE name = 'tree' LIMIT 1)
            ) AS rankCount,
            tn.name AS yearAB
        FROM taxonomy_toc toc
        JOIN taxonomy_node tn ON tn.taxnode_id = toc.tree_id
        WHERE toc.msl_release_num IS NOT NULL
        ORDER BY toc.msl_release_num DESC;

    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    

    
    OPEN releaseCursor;

    
    read_loop: LOOP
        FETCH releaseCursor INTO mslReleaseNum, rankCount, yearAB;
        IF done = 1 THEN
            LEAVE read_loop;
        END IF;

        
        SET dataJSON = CONCAT(
            dataJSON,
            '"', yearAB, '": { ',
                '"year": "', yearAB, '", ',
                '"rankCount": ', rankCount, ', ',
                '"releaseNum": ', mslReleaseNum, '},'
        );

        
        SET displayOrderJSON = CONCAT(displayOrderJSON, '"', yearAB, '",');
    END LOOP;

    
    CLOSE releaseCursor;

    
    IF CHAR_LENGTH(dataJSON) > 0 THEN
        SET dataJSON = LEFT(dataJSON, CHAR_LENGTH(dataJSON) - 1);
    END IF;

    IF CHAR_LENGTH(displayOrderJSON) > 0 THEN
        SET displayOrderJSON = LEFT(displayOrderJSON, CHAR_LENGTH(displayOrderJSON) - 1);
    END IF;

    
    SET finalJSON = CONCAT(
        '{ "data": {',
        dataJSON,
        '}, "displayOrder": [',
        displayOrderJSON,
        ']}'
    );

    
    SELECT finalJSON AS jsonResult;

END
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS exportTaxonomyJSON
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE exportTaxonomyJSON(IN treeID INT)
BEGIN
    
    DECLARE legendJSON LONGTEXT DEFAULT '';
    DECLARE jsonResult LONGTEXT DEFAULT '';
    DECLARE tempJSON LONGTEXT DEFAULT '';
    DECLARE tempEndJSON LONGTEXT DEFAULT '';
    DECLARE group_concat_max_len_value INT;

    
    SELECT @@group_concat_max_len INTO group_concat_max_len_value;
    IF group_concat_max_len_value < 1000000 THEN
        SET SESSION group_concat_max_len = 1000000;
    END IF;

    
    
    
    SELECT
        GROUP_CONCAT(rankJSON ORDER BY rank_index SEPARATOR '') INTO tempJSON
    FROM (
        SELECT
            CONCAT(
                '{',
                '"child_counts":null,',
                '"has_assigned_siblings":false,',
                '"has_species":false,',
                '"is_assigned":false,',
                '"has_unassigned_siblings":false,',
                '"name":"Unassigned",',
                '"parentDistance":1,',
                '"parentTaxNodeID":null,',
                '"rankIndex":', CAST(tr.rank_index AS CHAR), ',',
                '"rankName":"', tr.rank_name, '",',
                '"taxNodeID":"legend",',
                '"children":['
            ) AS rankJSON,
            tr.rank_index
        FROM taxonomy_json_rank tr
        WHERE tr.tree_id = treeID
          AND tr.rank_index > 0
        ORDER BY tr.rank_index
        LIMIT 100
    ) ranksJSON;

    
    SELECT
        GROUP_CONCAT(']}' ORDER BY rank_index SEPARATOR '') INTO tempEndJSON
    FROM (
        SELECT tr.rank_index
        FROM taxonomy_json_rank tr
        WHERE tr.tree_id = treeID
          AND tr.rank_index > 0
        ORDER BY tr.rank_index
    ) rankEnds;

    
    SET legendJSON = CONCAT(tempJSON, tempEndJSON);

    
    
    
    SELECT CONCAT(
        '{',
        tj.json,
        '"children":[',
        legendJSON,
        IF(CHAR_LENGTH(legendJSON) > 0 AND tj.child_json IS NOT NULL, ',', ''),
        IFNULL(tj.child_json, ''),
        ']}'
    ) INTO jsonResult
    FROM taxonomy_json tj
    WHERE tj.tree_id = treeID
      AND tj.taxnode_id = treeID
    LIMIT 1;

    
    SELECT jsonResult;

END
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS get_taxon_names_in_msl
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE get_taxon_names_in_msl
(
    IN  p_name NVARCHAR(250),
    IN  p_msl  INT
)
BEGIN
    
    SELECT sd.old_msl,
           sd.old_name,
           sd.new_count,
           dest.name
    FROM (
        SELECT
               
               src.msl_release_num           AS old_msl,
               src.name                      AS old_name,
               src.ictv_id                   AS old_ictv_id,
               dest.msl_release_num          AS new_msl,
               COUNT(DISTINCT dest.name)     AS new_count,
               CASE WHEN COUNT(DISTINCT dest.name) > 1
                        THEN 'multiple'
                    ELSE MAX(dest.name)
               END                           AS new_name
        FROM taxonomy_node             AS src
        JOIN taxonomy_node_merge_split AS ms
              ON ms.prev_ictv_id = src.ictv_id
        JOIN taxonomy_node             AS dest
              ON dest.ictv_id  = ms.next_ictv_id
        WHERE src.name = p_name
          AND dest.msl_release_num = p_msl
          AND ms.rev_count = 0
        GROUP BY
              src.msl_release_num,
              src.name,
              src.ictv_id,
              dest.msl_release_num
        ORDER BY new_msl DESC,
                 old_msl DESC
        LIMIT 1                                       
    ) AS sd
    JOIN taxonomy_node_merge_split AS ms
          ON ms.prev_ictv_id = sd.old_ictv_id
    JOIN taxonomy_node             AS dest
          ON dest.ictv_id = ms.next_ictv_id
         AND ms.rev_count = 0
         AND dest.msl_release_num = sd.new_msl;
END
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS `GetTaxonHistory`
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE GetTaxonHistory(
	
   
   IN `currentMSL` INT,

   
   IN `ictvID` INT,

   
   IN `MSL` INT,

   
   IN `taxNodeID` INT,

   
   IN `taxonName` VARCHAR(300),

   
   IN `vmrID` INT
)
BEGIN

   
   SET taxonName = TRIM(taxonName);

	
	
	IF taxNodeID IS NULL OR taxNodeID < 1 THEN
		IF ictvID IS NOT NULL AND ictvID > 0 THEN

         
         SELECT tn.taxnode_id INTO taxNodeID
         FROM taxonomy_node_names tn
         WHERE tn.ictv_id = ictvID
         AND (msl IS NULL OR (msl IS NOT NULL AND tn.msl_release_num = msl))
         ORDER BY tn.msl_release_num DESC
         LIMIT 1;

		ELSEIF vmrID IS NOT NULL AND vmrID > 0 THEN

         
         SELECT si.taxnode_id INTO taxNodeID
         FROM species_isolates si
         WHERE si.isolate_id = vmrID
         ORDER BY si.isolate_sort ASC
         LIMIT 1;

		ELSEIF taxonName IS NOT NULL AND LENGTH(taxonName) > 0 THEN

         
         SELECT tn.taxnode_id INTO taxNodeID
         FROM taxonomy_node_names tn
         WHERE tn.name = taxonName
         ORDER BY tn.msl_release_num DESC
         LIMIT 1;

		ELSE 
         SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Either taxnode_id, ictv_id, vmr_id, or taxon_name must be provided';
      END IF;
	END IF;

	
	IF taxNodeID IS NULL OR taxNodeID < 1 THEN
      SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Unable to determine taxnode_id';
   END IF;

   WITH taxaChanges AS (
      SELECT
         ictv_id,
         MAX(is_deleted) AS is_deleted,
         MAX(is_demoted) AS is_demoted,
         MAX(is_lineage_updated) AS is_lineage_updated,
         MAX(is_merged) AS is_merged,
         MAX(is_moved) AS is_moved,
         MAX(is_new) AS is_new,
         MAX(is_promoted) AS is_promoted,
         MAX(is_renamed) AS is_renamed,
         MAX(is_split) AS is_split,
         left_idx,
         level_id,
         lineage_ids,
         lineage_names,
         lineage_ranks,
         IFNULL(modifications,0) AS modifications,
         CASE
            WHEN MAX(is_deleted) = 1 THEN taxaAndPrevs.msl_release_num + 1
            ELSE taxaAndPrevs.msl_release_num
         END AS msl_release_num,
         name,
         MAX(prev_notes) AS prev_notes,
         MAX(prev_proposal) AS prev_proposal,
         taxnode_id,
         tree_id 

      FROM (
         SELECT 
            node.ictv_id,
            prev_delta.is_deleted,
            prev_delta.is_demoted,
            prev_delta.is_lineage_updated,
            prev_delta.is_merged,
            prev_delta.is_moved,
            prev_delta.is_new,
            prev_delta.is_promoted,
            prev_delta.is_renamed,
            prev_delta.is_split,
            node.left_idx,
            node.level_id,
            CONCAT(
               CASE WHEN node.realm_id IS NOT NULL THEN CONCAT(CAST(node.realm_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.subrealm_id IS NOT NULL THEN CONCAT(CAST(node.subrealm_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.kingdom_id IS NOT NULL THEN CONCAT(CAST(node.kingdom_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.subkingdom_id IS NOT NULL THEN CONCAT(CAST(node.subkingdom_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.phylum_id IS NOT NULL THEN CONCAT(CAST(node.phylum_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.subphylum_id IS NOT NULL THEN CONCAT(CAST(node.subphylum_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.class_id IS NOT NULL THEN CONCAT(CAST(node.class_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.subclass_id IS NOT NULL THEN CONCAT(CAST(node.subclass_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.order_id IS NOT NULL THEN CONCAT(CAST(node.order_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.suborder_id IS NOT NULL THEN CONCAT(CAST(node.suborder_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.family_id IS NOT NULL THEN CONCAT(CAST(node.family_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.subfamily_id IS NOT NULL THEN CONCAT(CAST(node.subfamily_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.genus_id IS NOT NULL THEN CONCAT(CAST(node.genus_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.subgenus_id IS NOT NULL THEN CONCAT(CAST(node.subgenus_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.species_id IS NOT NULL THEN CONCAT(CAST(node.species_id AS CHAR(12)), ';') ELSE '' END	
            ) AS lineage_ids,
            node.lineage AS lineage_names,
            CONCAT(
               CASE WHEN node.realm_id IS NOT NULL THEN 'Realm;' ELSE '' END, 
               CASE WHEN node.subrealm_id IS NOT NULL THEN 'Subrealm;' ELSE '' END, 
               CASE WHEN node.kingdom_id IS NOT NULL THEN 'Kingdom;' ELSE '' END, 
               CASE WHEN node.subkingdom_id IS NOT NULL THEN 'Subkingdom;' ELSE '' END, 
               CASE WHEN node.phylum_id IS NOT NULL THEN 'Phylum;' ELSE '' END, 
               CASE WHEN node.subphylum_id IS NOT NULL THEN 'Subphylum;' ELSE '' END, 
               CASE WHEN node.class_id IS NOT NULL THEN 'Class;' ELSE '' END, 
               CASE WHEN node.subclass_id IS NOT NULL THEN 'Subclass;' ELSE '' END, 
               CASE WHEN node.order_id IS NOT NULL THEN 'Order;' ELSE '' END, 
               CASE WHEN node.suborder_id IS NOT NULL THEN 'Suborder;' ELSE '' END, 
               CASE WHEN node.family_id IS NOT NULL THEN 'Family;' ELSE '' END, 
               CASE WHEN node.subfamily_id IS NOT NULL THEN 'Subfamily;' ELSE '' END, 
               CASE WHEN node.genus_id IS NOT NULL THEN 'Genus;' ELSE '' END, 
               CASE WHEN node.subgenus_id IS NOT NULL THEN 'Subgenus;' ELSE '' END, 
               CASE WHEN node.species_id IS NOT NULL THEN 'Species;' ELSE '' END 
            ) AS lineage_ranks,
            ( 
               prev_delta.is_deleted |
               prev_delta.is_demoted |
               prev_delta.is_lineage_updated |
               prev_delta.is_merged |
               prev_delta.is_moved |
               prev_delta.is_new |
               prev_delta.is_promoted |   
               prev_delta.is_renamed |   
               prev_delta.is_split
            ) AS modifications,
            node.msl_release_num,
            node.name,
            prev_delta.notes AS prev_notes,
            CASE
               WHEN prev_delta.proposal IS NOT NULL
                     THEN prev_delta.proposal
               WHEN prev_delta.tag_csv2 <> '' THEN (
                     SELECT d.proposal
                     FROM   taxonomy_node_delta d
                     JOIN   taxonomy_node       t ON d.new_taxid = t.taxnode_id
                     WHERE  node.left_idx  > t.left_idx
                        AND  node.right_idx < t.right_idx
                        AND  node.tree_id   = t.tree_id
                        AND  t.level_id  > 100
                        AND  d.proposal IS NOT NULL
                     ORDER BY t.level_id DESC
                     LIMIT 1
               )
END AS prev_proposal,
            
            node.taxnode_id AS taxnode_id,  
            node.tree_id AS tree_id

         FROM taxonomy_node_x AS node  
         LEFT JOIN taxonomy_node_delta AS prev_delta ON prev_delta.new_taxid = node.taxnode_id
         WHERE node.tree_id >= 19000000
         AND node.msl_release_num <= currentMSL 
         AND node.target_taxnode_id = taxNodeID

         UNION ALL

         
         SELECT 
            node.ictv_id,
            prev_delta.is_deleted,
            prev_delta.is_demoted,
            prev_delta.is_lineage_updated,
            prev_delta.is_merged,
            prev_delta.is_moved,
            prev_delta.is_new,
            prev_delta.is_promoted,
            prev_delta.is_renamed,
            prev_delta.is_split,
            node.left_idx,
            node.level_id,
            CONCAT(
               CASE WHEN node.realm_id IS NOT NULL THEN CONCAT(CAST(node.realm_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.subrealm_id IS NOT NULL THEN CONCAT(CAST(node.subrealm_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.kingdom_id IS NOT NULL THEN CONCAT(CAST(node.kingdom_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.subkingdom_id IS NOT NULL THEN CONCAT(CAST(node.subkingdom_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.phylum_id IS NOT NULL THEN CONCAT(CAST(node.phylum_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.subphylum_id IS NOT NULL THEN CONCAT(CAST(node.subphylum_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.class_id IS NOT NULL THEN CONCAT(CAST(node.class_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.subclass_id IS NOT NULL THEN CONCAT(CAST(node.subclass_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.order_id IS NOT NULL THEN CONCAT(CAST(node.order_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.suborder_id IS NOT NULL THEN CONCAT(CAST(node.suborder_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.family_id IS NOT NULL THEN CONCAT(CAST(node.family_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.subfamily_id IS NOT NULL THEN CONCAT(CAST(node.subfamily_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.genus_id IS NOT NULL THEN CONCAT(CAST(node.genus_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.subgenus_id IS NOT NULL THEN CONCAT(CAST(node.subgenus_id AS CHAR(12)), ';') ELSE '' END, 
               CASE WHEN node.species_id IS NOT NULL THEN CONCAT(CAST(node.species_id AS CHAR(12)), ';') ELSE '' END	
            ) AS lineage_ids,
            node.lineage AS lineage_names,
            CONCAT(
               CASE WHEN node.realm_id IS NOT NULL THEN 'Realm;' ELSE '' END, 
               CASE WHEN node.subrealm_id IS NOT NULL THEN 'Subrealm;' ELSE '' END, 
               CASE WHEN node.kingdom_id IS NOT NULL THEN 'Kingdom;' ELSE '' END, 
               CASE WHEN node.subkingdom_id IS NOT NULL THEN 'Subkingdom;' ELSE '' END, 
               CASE WHEN node.phylum_id IS NOT NULL THEN 'Phylum;' ELSE '' END, 
               CASE WHEN node.subphylum_id IS NOT NULL THEN 'Subphylum;' ELSE '' END, 
               CASE WHEN node.class_id IS NOT NULL THEN 'Class;' ELSE '' END, 
               CASE WHEN node.subclass_id IS NOT NULL THEN 'Subclass;' ELSE '' END, 
               CASE WHEN node.order_id IS NOT NULL THEN 'Order;' ELSE '' END, 
               CASE WHEN node.suborder_id IS NOT NULL THEN 'Suborder;' ELSE '' END, 
               CASE WHEN node.family_id IS NOT NULL THEN 'Family;' ELSE '' END, 
               CASE WHEN node.subfamily_id IS NOT NULL THEN 'Subfamily;' ELSE '' END, 
               CASE WHEN node.genus_id IS NOT NULL THEN 'Genus;' ELSE '' END, 
               CASE WHEN node.subgenus_id IS NOT NULL THEN 'Subgenus;' ELSE '' END, 
               CASE WHEN node.species_id IS NOT NULL THEN 'Species;' ELSE '' END 
            ) AS lineage_ranks,
            prev_delta.is_deleted AS modifications,
            node.msl_release_num AS msl_release_num,
            node.name,
            prev_delta.notes AS prev_notes,
            CASE
               WHEN prev_delta.proposal IS NOT NULL
                     THEN prev_delta.proposal
               WHEN prev_delta.tag_csv2 <> '' THEN (
                     SELECT d.proposal
                     FROM   taxonomy_node_delta d
                     JOIN   taxonomy_node       t ON d.new_taxid = t.taxnode_id
                     WHERE  node.left_idx  > t.left_idx
                        AND  node.right_idx < t.right_idx
                        AND  node.tree_id   = t.tree_id
                        AND  t.level_id  > 100
                        AND  d.proposal IS NOT NULL
                     ORDER BY t.level_id DESC
                     LIMIT 1
               )
END AS prev_proposal,
            
            node.taxnode_id AS taxnode_id,  
            node.tree_id

         FROM taxonomy_node_x AS node  
         JOIN taxonomy_node_delta AS prev_delta ON (
            prev_delta.is_deleted = 1 
            AND prev_delta.prev_taxid = node.taxnode_id
         )
         JOIN taxonomy_toc toc ON toc.msl_release_num = node.msl_release_num + 1
         WHERE node.tree_id >= 19000000
         AND node.msl_release_num <= currentMSL 
         AND node.target_taxnode_id = taxNodeID
      ) taxaAndPrevs

      GROUP BY taxaAndPrevs.msl_release_num, taxaAndPrevs.taxnode_id, taxaAndPrevs.tree_id, taxaAndPrevs.name, taxaAndPrevs.ictv_id, 
         taxaAndPrevs.is_deleted, taxaAndPrevs.is_demoted, taxaAndPrevs.is_lineage_updated, taxaAndPrevs.is_merged, 
         taxaAndPrevs.is_moved, taxaAndPrevs.is_new, taxaAndPrevs.is_promoted, taxaAndPrevs.is_renamed, taxaAndPrevs.is_split,
         taxaAndPrevs.left_idx, taxaAndPrevs.lineage_ids, taxaAndPrevs.lineage_names, taxaAndPrevs.modifications, taxaAndPrevs.msl_release_num, 
         taxaAndPrevs.name, taxaAndPrevs.prev_notes, taxaAndPrevs.prev_proposal
   )

   SELECT
      filteredTaxa.ictv_id,
      filteredTaxa.is_deleted,
      filteredTaxa.is_demoted,
      filteredTaxa.is_lineage_updated,
      filteredTaxa.is_merged,
      filteredTaxa.is_moved,
      filteredTaxa.is_new,
      filteredTaxa.is_promoted,
      filteredTaxa.is_renamed,
      CASE
         WHEN filteredTaxa.taxnode_id = taxNodeID THEN 1 ELSE 0
      END AS is_selected,
      filteredTaxa.is_split,
      filteredTaxa.lineage_ids,
      filteredTaxa.lineage_names,
      filteredTaxa.lineage_ranks,
      filteredTaxa.msl_release_num,
      filteredTaxa.name,
      
      
      prev_tn.lineage AS prev_lineage_names,
      CONCAT(
         CASE WHEN prev_tn.realm_id IS NOT NULL THEN 'Realm;' ELSE '' END, 
         CASE WHEN prev_tn.subrealm_id IS NOT NULL THEN 'Subrealm;' ELSE '' END, 
         CASE WHEN prev_tn.kingdom_id IS NOT NULL THEN 'Kingdom;' ELSE '' END, 
         CASE WHEN prev_tn.subkingdom_id IS NOT NULL THEN 'Subkingdom;' ELSE '' END, 
         CASE WHEN prev_tn.phylum_id IS NOT NULL THEN 'Phylum;' ELSE '' END, 
         CASE WHEN prev_tn.subphylum_id IS NOT NULL THEN 'Subphylum;' ELSE '' END, 
         CASE WHEN prev_tn.class_id IS NOT NULL THEN 'Class;' ELSE '' END, 
         CASE WHEN prev_tn.subclass_id IS NOT NULL THEN 'Subclass;' ELSE '' END, 
         CASE WHEN prev_tn.order_id IS NOT NULL THEN 'Order;' ELSE '' END, 
         CASE WHEN prev_tn.suborder_id IS NOT NULL THEN 'Suborder;' ELSE '' END, 
         CASE WHEN prev_tn.family_id IS NOT NULL THEN 'Family;' ELSE '' END, 
         CASE WHEN prev_tn.subfamily_id IS NOT NULL THEN 'Subfamily;' ELSE '' END, 
         CASE WHEN prev_tn.genus_id IS NOT NULL THEN 'Genus;' ELSE '' END, 
         CASE WHEN prev_tn.subgenus_id IS NOT NULL THEN 'Subgenus;' ELSE '' END, 
         CASE WHEN prev_tn.species_id IS NOT NULL THEN 'Species;' ELSE '' END 
      ) AS prev_lineage_ranks,
      
      
      CASE
         WHEN filteredTaxa.is_deleted = 0 AND (filteredTaxa.is_merged = 1 OR filteredTaxa.is_renamed = 1 OR filteredTaxa.is_split = 1) THEN

            
            (SELECT GROUP_CONCAT(tn_previous.name ORDER BY tn_previous.left_idx SEPARATOR ', ')
            FROM taxonomy_node tn_changed
            JOIN taxonomy_node_merge_split ms_changed ON ms_changed.prev_ictv_id = tn_changed.ictv_id
            JOIN taxonomy_node tn_previous ON tn_previous.ictv_id = ms_changed.next_ictv_id
            JOIN taxonomy_node_delta delta_previous ON (
               delta_previous.new_taxid = tn_changed.taxnode_id
               AND delta_previous.prev_taxid = tn_previous.taxnode_id
            )
            WHERE tn_changed.taxnode_id = filteredTaxa.taxnode_id
            AND tn_previous.msl_release_num = (filteredTaxa.msl_release_num - 1)
            )
         ELSE NULL
      END AS prev_names,
      filteredTaxa.prev_notes,
      filteredTaxa.prev_proposal,
      tl.name AS rank_name,
      filteredTaxa.taxnode_id,
      filteredTaxa.tree_id,

      
      filteredTaxa.release_is_current,
      filteredTaxa.release_is_visible,
      filteredTaxa.release_number,
      CONCAT(
         CASE WHEN realms > 0 THEN 'realm,' ELSE '' END,  
         CASE WHEN subrealms > 0 THEN 'subrealm,' ELSE '' END,  
         CASE WHEN kingdoms > 0 THEN 'kingdom,' ELSE '' END,  
         CASE WHEN subkingdoms > 0 THEN 'subkingdom,' ELSE '' END,  
         CASE WHEN phyla > 0 THEN 'phylum,' ELSE '' END,  
         CASE WHEN subphyla > 0 THEN 'subphylum,' ELSE '' END,  
         CASE WHEN classes > 0 THEN 'class,' ELSE '' END,  
         CASE WHEN subclasses > 0 THEN 'subclass,' ELSE '' END,  
         CASE WHEN orders > 0 THEN 'order,' ELSE '' END,  
         CASE WHEN suborders > 0 THEN 'suborder,' ELSE '' END,  
         CASE WHEN families > 0 THEN 'family,' ELSE '' END,  
         CASE WHEN subfamilies > 0 THEN 'subfamily,' ELSE '' END,  
         CASE WHEN genera > 0 THEN 'genus,' ELSE '' END,  
         CASE WHEN subgenera > 0 THEN 'subgenus,' ELSE '' END,  
         CASE WHEN msl.species > 0 THEN 'species' ELSE '' END  
      ) AS release_rank_names,
      SUBSTRING(msl.notes, 1, 255) AS release_title,  
      msl.year AS release_year

   FROM (
      SELECT
         ictv_id,
         is_deleted,
         is_demoted,
         is_lineage_updated,
         is_merged,
         is_moved,
         is_new,
         is_promoted,
         is_renamed,
         is_split,
         left_idx,
         level_id,
         lineage_ids,
         lineage_names,
         lineage_ranks,
         tc1.msl_release_num,
         name,
         prev_notes,
         prev_proposal,
         taxnode_id,
         tree_id,

         
         releases.is_current AS release_is_current,
         CASE 
            WHEN releases.is_current = 1 OR releases.mods > 0 THEN 1 ELSE 0
         END AS release_is_visible,
         releases.msl_release_num AS release_number

      FROM taxaChanges tc1

      
      JOIN (
         SELECT
            CASE 
	         	WHEN 0 < SUM(CASE WHEN tc2.taxnode_id = taxNodeID THEN 1 ELSE 0 END) THEN 1 ELSE 0 
	         END AS has_selected_taxon,
            CASE WHEN tc2.msl_release_num = currentMSL THEN 1 ELSE 0 END AS is_current,
            SUM(tc2.modifications) AS mods,
            tc2.msl_release_num
         FROM taxaChanges tc2
         GROUP BY tc2.msl_release_num
      ) releases ON (
     	   releases.msl_release_num = tc1.msl_release_num
     	   AND (releases.is_current = 1 
            OR releases.mods > 0 
            OR (releases.has_selected_taxon = 1 AND tc1.taxnode_id = taxNodeID)
     	   )
      )
   ) filteredTaxa

   
   JOIN taxonomy_level tl ON tl.id = filteredTaxa.level_id

   
   LEFT JOIN taxonomy_node prev_tn ON (
      (is_demoted = 1 OR is_lineage_updated = 1 OR is_moved = 1 OR is_promoted = 1)
      AND prev_tn.ictv_id = filteredTaxa.ictv_id
      AND prev_tn.msl_release_num = filteredTaxa.msl_release_num - 1
   )

   
   JOIN view_taxa_level_counts_by_release msl ON msl.msl_release_num = filteredTaxa.msl_release_num

   ORDER BY 

      
      filteredTaxa.msl_release_num DESC,

      
      filteredTaxa.left_idx ASC,

      
      is_new DESC,
      filteredTaxa.is_deleted DESC,
      is_promoted DESC,
      is_demoted DESC,
      is_merged DESC,
      is_split DESC,
      is_moved DESC, 
      is_lineage_updated DESC,
      is_renamed DESC;

END
--------------

Query OK, 0 rows affected (0.010 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS getVirusIsolates
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE getVirusIsolates(
    IN mslRelease INT,
    IN onlyUnassigned BOOLEAN,
    IN searchTaxon NVARCHAR(100)
)
BEGIN
    DECLARE errorMsg VARCHAR(200);
    DECLARE errorCode INT DEFAULT 50000;
    DECLARE targetLeftIndex INT;
    DECLARE targetLevelID INT;
    DECLARE targetRightIndex INT;
    DECLARE targetTaxNodeID INT;
    DECLARE speciesLevelID INT;

    
    IF searchTaxon IS NULL OR CHAR_LENGTH(TRIM(searchTaxon)) < 1 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Invalid searchTaxonName parameter';
    END IF;

    
    IF mslRelease IS NULL OR mslRelease < 1 THEN
        SELECT MAX(msl_release_num) INTO mslRelease FROM taxonomy_toc;
    END IF;

    
    SELECT target.left_idx, target.level_id, target.right_idx, target.taxnode_id
    INTO targetLeftIndex, targetLevelID, targetRightIndex, targetTaxNodeID
    FROM taxonomy_node target
    WHERE target.name = searchTaxon
      AND target.msl_release_num = mslRelease
    LIMIT 1;

    IF targetLeftIndex IS NULL OR targetLevelID IS NULL OR targetRightIndex IS NULL OR targetTaxNodeID IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Invalid target node values';
    END IF;

    
    SELECT id INTO speciesLevelID FROM taxonomy_level WHERE name = 'species' LIMIT 1;

    IF speciesLevelID IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Could not find species level ID';
    END IF;

    
    SELECT 
        si.isolate_id AS isolate_id,
        IFNULL(si.isolate_abbrevs, '') AS abbrev,
        IFNULL(si.genbank_accessions, '') AS accession_number,
        IFNULL(si.isolate_names, '') AS alternative_name_csv,
        IFNULL(si.genome_coverage, '') AS available_sequence,
        si.isolate_type AS exemplar,
        IFNULL(si.isolate_designation, '') AS isolate,
        IFNULL(si.refseq_accessions, '') AS refseq_accession,
        species.taxnode_id,

        IFNULL(subrealm.name, '') AS subrealm,
        IFNULL(kingdom.name, '') AS kingdom,
        IFNULL(subkingdom.name, '') AS subkingdom,
        IFNULL(phylum.name, '') AS phylum,
        IFNULL(class.name, '') AS class,
        IFNULL(subclass.name, '') AS subclass,
        IFNULL(`order`.name, '') AS `order`,
        IFNULL(suborder.name, '') AS suborder,
        IFNULL(family.name, '') AS family,
        IFNULL(subfamily.name, '') AS subfamily,
        IFNULL(genus.name, '') AS genus,
        IFNULL(subgenus.name, '') AS subgenus,
        species.name AS species

    FROM taxonomy_node species
    JOIN species_isolates si ON si.taxnode_id = species.taxnode_id

    LEFT JOIN taxonomy_node subrealm ON (
        species.subrealm_id IS NOT NULL
        AND subrealm.taxnode_id = species.subrealm_id
        AND subrealm.level_id > targetLevelID
    )

    LEFT JOIN taxonomy_node kingdom ON (
        species.kingdom_id IS NOT NULL
        AND kingdom.taxnode_id = species.kingdom_id
        AND kingdom.level_id > targetLevelID
    )

    LEFT JOIN taxonomy_node subkingdom ON (
        species.subkingdom_id IS NOT NULL
        AND subkingdom.taxnode_id = species.subkingdom_id
        AND subkingdom.level_id > targetLevelID
    )

    LEFT JOIN taxonomy_node phylum ON (
        species.phylum_id IS NOT NULL
        AND phylum.taxnode_id = species.phylum_id
        AND phylum.level_id > targetLevelID
    )

    LEFT JOIN taxonomy_node subphylum ON (
        species.subphylum_id IS NOT NULL
        AND subphylum.taxnode_id = species.subphylum_id
        AND subphylum.level_id > targetLevelID
    )

    LEFT JOIN taxonomy_node class ON (
        species.class_id IS NOT NULL
        AND class.taxnode_id = species.class_id
        AND class.level_id > targetLevelID
    )

    LEFT JOIN taxonomy_node subclass ON (
        species.subclass_id IS NOT NULL
        AND subclass.taxnode_id = species.subclass_id
        AND subclass.level_id > targetLevelID
    )

    LEFT JOIN taxonomy_node `order` ON (
        species.order_id IS NOT NULL
        AND `order`.taxnode_id = species.order_id
        AND `order`.level_id > targetLevelID
    )

    LEFT JOIN taxonomy_node suborder ON (
        species.suborder_id IS NOT NULL
        AND suborder.taxnode_id = species.suborder_id
        AND suborder.level_id > targetLevelID
    )

    LEFT JOIN taxonomy_node family ON (
        species.family_id IS NOT NULL
        AND family.taxnode_id = species.family_id
        AND family.level_id > targetLevelID
    )

    LEFT JOIN taxonomy_node subfamily ON (
        species.subfamily_id IS NOT NULL
        AND subfamily.taxnode_id = species.subfamily_id
        AND subfamily.level_id > targetLevelID
    )

    LEFT JOIN taxonomy_node genus ON genus.taxnode_id = species.genus_id

    LEFT JOIN taxonomy_node subgenus ON (
        species.subgenus_id IS NOT NULL
        AND subgenus.taxnode_id = species.subgenus_id
        AND subgenus.level_id > targetLevelID
    )

    WHERE species.left_idx BETWEEN targetLeftIndex AND targetRightIndex
      AND species.msl_release_num = mslRelease
      AND species.is_deleted = 0
      AND species.is_hidden = 0
      AND species.is_obsolete = 0
      AND species.level_id = speciesLevelID
      AND (
           onlyUnassigned = 0
           OR (
               onlyUnassigned = 1
               AND (
                   genus.name = 'unassigned' 
                   OR (species.genus_id IS NULL AND species.subgenus_id IS NULL)
               )
               AND species.parent_id = targetTaxNodeID
           )
         )
    ORDER BY species.left_idx, si.isolate_sort;

END
--------------

Query OK, 0 rows affected (0.007 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS initializeTaxonomyJsonRanks
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE initializeTaxonomyJsonRanks()
BEGIN
    
    DECLARE treeID INT;
    DECLARE done INT DEFAULT 0;

    
    DECLARE tree_cursor CURSOR FOR
        SELECT DISTINCT tree_id 
        FROM taxonomy_toc 
        WHERE msl_release_num IS NOT NULL
          AND tree_id NOT IN (
              SELECT tree_id
              FROM taxonomy_json_rank
          );

    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    
    
    
    DELETE FROM taxonomy_json_rank;

    
    
    
    OPEN tree_cursor;

    read_loop: LOOP
        FETCH tree_cursor INTO treeID;
        IF done = 1 THEN
            LEAVE read_loop;
        END IF;

        
        INSERT INTO taxonomy_json_rank (
            level_id,
            rank_index,
            rank_name,
            tree_id
        )
        SELECT 
            levels.level_id,
            rn.rank_index,
            tl.name AS rank_name,
            treeID AS tree_id
        FROM (
            SELECT DISTINCT tn.level_id
            FROM taxonomy_node tn
            WHERE tn.tree_id = treeID
        ) levels
        JOIN taxonomy_level tl ON tl.id = levels.level_id
        JOIN (
            SELECT
                level_id,
                (ROW_NUMBER() OVER (ORDER BY level_id ASC) - 1) AS rank_index
            FROM (
                SELECT DISTINCT tn.level_id
                FROM taxonomy_node tn
                WHERE tn.tree_id = treeID
            ) tn_levels
        ) rn ON rn.level_id = levels.level_id
        ORDER BY levels.level_id;

    END LOOP read_loop;

    CLOSE tree_cursor;

END
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS MSL_delta_counts
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE MSL_delta_counts(IN msl_or_tree INT)
BEGIN
    
    DECLARE msl INT;

    
    SELECT MAX(msl_release_num) INTO msl
    FROM taxonomy_toc
    WHERE msl_or_tree IS NULL OR msl_release_num = msl_or_tree OR tree_id = msl_or_tree;

    
    SELECT CONCAT('TARGET MSL:', RTRIM(msl)) AS target_msl;

    
    SELECT 
        
        tax_level.name AS `rank`,
        
        msl - 1 AS old_msl,
        (
            SELECT COUNT(*)
            FROM taxonomy_node tn
            WHERE tn.msl_release_num = msl - 1
              AND tn.level_id = tax_level.id
        ) AS old_msl_ct,
        
        '+' AS `plus`,
        (
            SELECT COUNT(*)
            FROM taxonomy_node_delta tax_delta
            JOIN taxonomy_node tnode ON tnode.taxnode_id = tax_delta.new_taxid
            WHERE tnode.msl_release_num = msl
              AND tax_delta.is_new = 1
              AND tnode.level_id = tax_level.id
        ) AS `create`,
        (
            SELECT COUNT(*)
            FROM taxonomy_node_delta tax_delta
            JOIN taxonomy_node tnode ON tnode.taxnode_id = tax_delta.new_taxid
            WHERE tnode.msl_release_num = msl
              AND tax_delta.is_promoted = 1
              AND tnode.level_id = tax_level.id
        ) AS create_by_promote,
        (
            SELECT COUNT(*)
            FROM taxonomy_node_delta tax_delta
            JOIN taxonomy_node tnode ON tnode.taxnode_id = tax_delta.new_taxid
            WHERE tnode.msl_release_num = msl
              AND tax_delta.is_demoted = 1
              AND tnode.level_id = tax_level.id
        ) AS create_by_demote,
        (
            SELECT COUNT(DISTINCT delta.new_taxid) - COUNT(DISTINCT delta.prev_taxid)
            FROM taxonomy_node_delta delta
            WHERE delta.prev_taxid IN (
                SELECT tn.taxnode_id
                FROM taxonomy_node tn
                JOIN taxonomy_node_delta tax_delta ON tax_delta.prev_taxid = tn.taxnode_id
                WHERE tn.msl_release_num = msl - 1
                  AND tax_delta.is_split = 1
                  AND tn.level_id = tax_level.id
            )
        ) AS create_by_split,
        '-' AS `minus`,
        (
            SELECT -COUNT(*)
            FROM taxonomy_node_delta tax_delta
            JOIN taxonomy_node tnode ON tnode.taxnode_id = tax_delta.prev_taxid
            WHERE tnode.msl_release_num = msl - 1
              AND tax_delta.is_deleted = 1
              AND tnode.level_id = tax_level.id
        ) AS abolish,
        (
            SELECT COUNT(DISTINCT delta.new_taxid) - COUNT(DISTINCT delta.prev_taxid)
            FROM taxonomy_node_delta delta
            WHERE delta.new_taxid IN (
                SELECT tn.taxnode_id
                FROM taxonomy_node tn
                JOIN taxonomy_node_delta tax_delta ON tax_delta.new_taxid = tn.taxnode_id
                WHERE tn.msl_release_num = msl
                  AND tax_delta.is_merged = 1
                  AND tn.level_id = tax_level.id
            )
        ) AS abolish_by_merge,
        (
            SELECT -COUNT(*)
            FROM taxonomy_node_delta tax_delta
            JOIN taxonomy_node tnode ON tnode.taxnode_id = tax_delta.prev_taxid
            WHERE tnode.msl_release_num = msl - 1
              AND tax_delta.is_promoted = 1
              AND tnode.level_id = tax_level.id
        ) AS abolish_by_promote,
        (
            SELECT -COUNT(*)
            FROM taxonomy_node_delta tax_delta
            JOIN taxonomy_node tnode ON tnode.taxnode_id = tax_delta.prev_taxid
            WHERE tnode.msl_release_num = msl - 1
              AND tax_delta.is_demoted = 1
              AND tnode.level_id = tax_level.id
        ) AS abolish_by_demote,
        '~' AS `same`,
        (
            SELECT COUNT(*)
            FROM taxonomy_node_delta tax_delta
            JOIN taxonomy_node tnode ON tnode.taxnode_id = tax_delta.new_taxid
            WHERE tnode.msl_release_num = msl
              AND tax_delta.is_moved = 1
              AND tnode.level_id = tax_level.id
        ) AS action_move,
        (
            SELECT COUNT(*)
            FROM taxonomy_node_delta tax_delta
            JOIN taxonomy_node tnode ON tnode.taxnode_id = tax_delta.new_taxid
            WHERE tnode.msl_release_num = msl
              AND tax_delta.is_renamed = 1
              AND tnode.level_id = tax_level.id
        ) AS action_rename,
        (
            SELECT COUNT(*)
            FROM taxonomy_node_delta tax_delta
            JOIN taxonomy_node tnode ON tnode.taxnode_id = tax_delta.new_taxid
            WHERE tnode.msl_release_num = msl
              AND tax_delta.is_lineage_updated = 1
              AND tnode.level_id = tax_level.id
        ) AS action_lineage_update,
        
        '=' AS `eq`,
        (
            SELECT COUNT(*)
            FROM taxonomy_node tn
            WHERE tn.msl_release_num = msl
              AND tn.level_id = tax_level.id
        ) AS new_msl_ct,
        msl AS new_msl
    FROM taxonomy_level tax_level
    WHERE tax_level.name <> 'tree'
    ORDER BY tax_level.id;

    
    SELECT  
        p.msl,
        p.rank,
        p.name,
        p.taxnode_id,
        '<PREV<' AS `PREV`,
        d.*,
        '>NEXT>' AS `NEXT`,
        n.taxnode_id,
        n.name,
        n.rank,
        n.msl
    FROM taxonomy_node_delta d
    LEFT JOIN taxonomy_node_names p ON p.taxnode_id = d.prev_taxid
    LEFT JOIN taxonomy_node_names n ON n.taxnode_id = d.new_taxid
    WHERE d.msl = msl
      AND (p.msl IS NOT NULL OR n.msl IS NOT NULL)
    ORDER BY IFNULL(n.lineage, p.lineage);
END
--------------

Query OK, 0 rows affected (0.007 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS MSL_delta_report
--------------

Query OK, 0 rows affected (0.004 sec)

--------------
CREATE PROCEDURE MSL_delta_report(IN in_msl INT)
BEGIN
    DECLARE msl INT;
    DECLARE prev_msl INT;

    
    SET msl = in_msl;

    
    IF msl IS NULL THEN
        SELECT MAX(msl_release_num) INTO msl FROM taxonomy_node;
    END IF;

    
    SET prev_msl = msl - 1;

    
    SELECT 'TARGET MSLs' AS target_msls,
           msl AS `current`,
           prev_msl AS `prev`,
           CONCAT('Deltas MSL', RTRIM(prev_msl), ' v ', RTRIM(msl)) AS excel_tab_name;

    
    SELECT 
        IFNULL(RTRIM(prev.left_idx), '') AS sort_old,
        IFNULL(plevel.name, '') AS old_level,
        IFNULL(prev.lineage, '') AS old_lineage,
        delta.tag_csv AS `change`,
        IFNULL(delta.proposal, '') AS proposal,
        IFNULL(dlevel.name, '') AS new_level,
        IFNULL(dx.lineage, '') AS new_lineage,
        IFNULL(dx.left_idx, '') AS sort_new
    FROM taxonomy_node_delta delta
    LEFT JOIN taxonomy_node dx ON delta.new_taxid = dx.taxnode_id
    LEFT JOIN taxonomy_level dlevel ON dlevel.id = dx.level_id
    LEFT JOIN taxonomy_node prev ON prev.taxnode_id = delta.prev_taxid
    LEFT JOIN taxonomy_level plevel ON plevel.id = prev.level_id
    WHERE (dx.msl_release_num = msl AND delta.tag_csv <> '')
       OR (prev.msl_release_num = prev_msl AND delta.is_deleted = 1)
    ORDER BY dx.left_idx, prev.left_idx;
END
--------------

Query OK, 0 rows affected (0.006 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS MSL_export_fast
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE MSL_export_fast(IN msl_or_tree INT, IN taxnode_id INT)
BEGIN
    
    DECLARE msl INT;
    DECLARE tree_id INT;
    DECLARE notes TEXT;

    
    
    

    
    SELECT toc.tree_id, toc.msl_release_num, toc.notes INTO tree_id, msl, notes
    FROM taxonomy_toc toc
    WHERE msl_or_tree IS NULL OR toc.msl_release_num = msl_or_tree OR toc.tree_id = msl_or_tree
    ORDER BY toc.msl_release_num DESC
    LIMIT 1;

    
    SELECT CONCAT('TARGET MSL: ', msl) AS target_msl, CONCAT('TARGET TREE: ', tree_id) AS target_tree;

    
    SELECT 'THIS EXPORT DOES NOT PULL HISTORY INFO, and GENOME_MOLECULE is ONLY FROM CUR MSL, NO FALLBACK TO OLDER MSLs IF THERE IS MISSING INFO' AS WARNING;
    SELECT 'FOR FULL EXPORT USE:' AS ADVICE, 'exec MSL_export_official' AS `SQL`;

    
    SELECT 
        'version info:' AS PASTE_TEXT_FOR_VERSION_WORKSHEET,
        CONCAT('ICTV ', LEFT(RTRIM(tree_id), 4), ' Master Species List (MSL', RTRIM(msl), ')') AS cell_2B,
        'update today''s date!' AS cell_5C,
        CONCAT('New MSL including all taxa updates since the ', (SELECT name FROM taxonomy_node WHERE level_id = 100 AND msl_release_num = (msl - 1)), ' release') AS cell_6E,
        CONCAT('Updates approved during ', CAST(notes AS CHAR)) AS cell_7F,
        CONCAT('and ratified by the ICTV membership in ', LEFT(RTRIM(tree_id + 10000), 4)) AS cell_8F,
        CONCAT('ICTV', LEFT(RTRIM(tree_id), 4), ' Master Species List#', RTRIM(msl)) AS taxa_tab_name
    FROM taxonomy_node
    WHERE level_id = 100
      AND msl_release_num = msl;

    
    SELECT 'molecule stats' AS REPORT, m.*, 
        (SELECT COUNT(n.taxnode_id) FROM taxonomy_node n WHERE n.inher_molecule_id = m.id AND n.tree_id = tree_id) AS `usage`
    FROM taxonomy_molecule m
    ORDER BY id;

    
    SELECT 'rank stats' AS REPORT, l.*, 
        (SELECT COUNT(n.taxnode_id) FROM taxonomy_node n WHERE n.level_id = l.id AND n.tree_id = tree_id) AS `usage`
    FROM taxonomy_level l
    ORDER BY id;

    
    SELECT
        ROW_NUMBER() OVER(ORDER BY tn.left_idx ASC) AS `sort`,
        IFNULL(`realm`.name, '') AS `realm`,
        IFNULL(`subrealm`.name, '') AS `subrealm`,
        IFNULL(`kingdom`.name, '') AS `kingdom`,
        IFNULL(`subkingdom`.name, '') AS `subkingdom`,
        IFNULL(`phylum`.name, '') AS `phylum`,
        IFNULL(`subphylum`.name, '') AS `subphylum`,
        IFNULL(`class`.name, '') AS `class`,
        IFNULL(`subclass`.name, '') AS `subclass`,
        IFNULL(`order`.name, '') AS `order`,
        IFNULL(`suborder`.name, '') AS `suborder`,
        IFNULL(`family`.name, '') AS `family`,
        IFNULL(`subfamily`.name, '') AS `subfamily`,
        IFNULL(`genus`.name, '') AS `genus`,
        IFNULL(`subgenus`.name, '') AS `subgenus`,
        IFNULL(`species`.name, '') AS `species`,
        
        IFNULL((
            SELECT mol.abbrev
            FROM taxonomy_molecule mol
            WHERE mol.id = tn.inher_molecule_id
            LIMIT 1
        ), '') AS molecule,
        
        'exec MSL_export_official' AS last_change,
        'exec MSL_export_official' AS last_change_msl,
        'exec MSL_export_official' AS last_change_proposal,
        
        CONCAT('=HYPERLINK("https://ictv.global/taxonomy/taxondetails?taxnode_id=', RTRIM(tn.taxnode_id), '","ictv.global=', RTRIM(tn.taxnode_id), '")') AS history_url
    FROM taxonomy_node tn
    LEFT JOIN taxonomy_node `tree` ON `tree`.taxnode_id = tn.tree_id
    LEFT JOIN taxonomy_node `realm` ON `realm`.taxnode_id = tn.realm_id
    LEFT JOIN taxonomy_node `subrealm` ON `subrealm`.taxnode_id = tn.subrealm_id
    LEFT JOIN taxonomy_node `kingdom` ON `kingdom`.taxnode_id = tn.kingdom_id
    LEFT JOIN taxonomy_node `subkingdom` ON `subkingdom`.taxnode_id = tn.subkingdom_id
    LEFT JOIN taxonomy_node `phylum` ON `phylum`.taxnode_id = tn.phylum_id
    LEFT JOIN taxonomy_node `subphylum` ON `subphylum`.taxnode_id = tn.subphylum_id
    LEFT JOIN taxonomy_node `class` ON `class`.taxnode_id = tn.class_id
    LEFT JOIN taxonomy_node `subclass` ON `subclass`.taxnode_id = tn.subclass_id
    LEFT JOIN taxonomy_node `order` ON `order`.taxnode_id = tn.order_id
    LEFT JOIN taxonomy_node `suborder` ON `suborder`.taxnode_id = tn.suborder_id
    LEFT JOIN taxonomy_node `family` ON `family`.taxnode_id = tn.family_id
    LEFT JOIN taxonomy_node `subfamily` ON `subfamily`.taxnode_id = tn.subfamily_id
    LEFT JOIN taxonomy_node `genus` ON `genus`.taxnode_id = tn.genus_id
    LEFT JOIN taxonomy_node `subgenus` ON `subgenus`.taxnode_id = tn.subgenus_id
    LEFT JOIN taxonomy_node `species` ON `species`.taxnode_id = tn.species_id
    WHERE tn.is_deleted = 0 AND tn.is_hidden = 0 AND tn.is_obsolete = 0
      AND tn.tree_id = tree_id
      AND tn.level_id = 600 
      
      AND (taxnode_id IS NULL OR tn.taxnode_id = taxnode_id)
    ORDER BY tn.left_idx;

END
--------------

Query OK, 0 rows affected (0.007 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS MSL_export_official
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE MSL_export_official(IN msl_or_tree INT, IN taxnode_id INT)
BEGIN
    
    DECLARE msl INT;
    DECLARE tree_id INT;
    DECLARE notes TEXT;

    
    
    

    
    SELECT toc.tree_id, toc.msl_release_num, toc.notes INTO tree_id, msl, notes
    FROM taxonomy_toc toc
    WHERE msl_or_tree IS NULL OR toc.msl_release_num = msl_or_tree OR toc.tree_id = msl_or_tree
    ORDER BY toc.msl_release_num DESC
    LIMIT 1;

    
    SELECT CONCAT('TARGET MSL: ', msl) AS target_msl, CONCAT('TARGET TREE: ', tree_id) AS target_tree;

    
    SELECT 
        'version info:' AS PASTE_TEXT_FOR_VERSION_WORKSHEET,
        CONCAT('ICTV ', LEFT(RTRIM(tree_id), 4), ' Master Species List (MSL', RTRIM(msl), ')') AS cell_2B,
        'update today''s date!' AS cell_5C,
        CONCAT('New MSL including all taxa updates since the ', (SELECT name FROM taxonomy_node WHERE level_id = 100 AND msl_release_num = (msl - 1)), ' release') AS cell_6E,
        CONCAT('Updates approved during ', CAST(notes AS CHAR)) AS cell_7F,
        CONCAT('and ratified by the ICTV membership in ', LEFT(RTRIM(tree_id + 10000), 4)) AS cell_8F,
        CONCAT('ICTV', LEFT(RTRIM(tree_id), 4), ' Master Species List#', RTRIM(msl)) AS taxa_tab_name
    FROM taxonomy_node
    WHERE level_id = 100
      AND msl_release_num = msl;

    
    SELECT 'molecule stats' AS REPORT, m.*, 
        (SELECT COUNT(n.taxnode_id) FROM taxonomy_node n WHERE n.inher_molecule_id = m.id AND n.tree_id = tree_id) AS `usage`
    FROM taxonomy_molecule m
    ORDER BY id;

    
    SELECT 'rank stats' AS REPORT, l.*, 
        (SELECT COUNT(n.taxnode_id) FROM taxonomy_node n WHERE n.level_id = l.id AND n.tree_id = tree_id) AS `usage`
    FROM taxonomy_level l
    ORDER BY id;

    
    SELECT
        ROW_NUMBER() OVER(ORDER BY tn.left_idx ASC) AS `sort`,
        IFNULL(`realm`.name, '') AS `realm`,
        IFNULL(`subrealm`.name, '') AS `subrealm`,
        IFNULL(`kingdom`.name, '') AS `kingdom`,
        IFNULL(`subkingdom`.name, '') AS `subkingdom`,
        IFNULL(`phylum`.name, '') AS `phylum`,
        IFNULL(`subphylum`.name, '') AS `subphylum`,
        IFNULL(`class`.name, '') AS `class`,
        IFNULL(`subclass`.name, '') AS `subclass`,
        IFNULL(`order`.name, '') AS `order`,
        IFNULL(`suborder`.name, '') AS `suborder`,
        IFNULL(`family`.name, '') AS `family`,
        IFNULL(`subfamily`.name, '') AS `subfamily`,
        IFNULL(`genus`.name, '') AS `genus`,
        IFNULL(`subgenus`.name, '') AS `subgenus`,
        IFNULL(`species`.name, '') AS `species`,
        
        IFNULL((
            SELECT mol.abbrev
            FROM taxonomy_node_merge_split tms
            JOIN taxonomy_node t ON
                t.ictv_id = tms.prev_ictv_id
                AND t.tree_id <= tn.tree_id
            JOIN taxonomy_node tancestor ON
                tancestor.left_idx <= t.left_idx AND tancestor.right_idx >= t.right_idx
                AND tancestor.tree_id = t.tree_id AND tancestor.level_id > 100
            JOIN taxonomy_molecule mol ON mol.id = tancestor.inher_molecule_id
            WHERE tms.next_ictv_id = tn.ictv_id
              AND mol.abbrev IS NOT NULL
            ORDER BY tn.tree_id - tancestor.tree_id, tancestor.node_depth DESC
            LIMIT 1
        ), '') AS molecule,
        
        (
            SELECT dx.prev_tags
            FROM taxonomy_node_merge_split tms
            JOIN taxonomy_node t ON
                t.ictv_id = tms.prev_ictv_id
                AND t.tree_id <= tn.tree_id
            JOIN taxonomy_node_dx dx ON
                dx.left_idx <= t.left_idx AND dx.right_idx >= t.right_idx
                AND dx.tree_id = t.tree_id AND dx.level_id > 100
                AND dx.prev_tags IS NOT NULL AND dx.prev_tags <> ''
            WHERE tms.next_ictv_id = tn.ictv_id
            ORDER BY tn.tree_id - dx.tree_id, dx.node_depth DESC
            LIMIT 1
        ) AS last_change,
        
        (
            SELECT dx.msl_release_num
            FROM taxonomy_node_merge_split tms
            JOIN taxonomy_node t ON
                t.ictv_id = tms.prev_ictv_id
                AND t.tree_id <= tn.tree_id
            JOIN taxonomy_node_dx dx ON
                dx.left_idx <= t.left_idx AND dx.right_idx >= t.right_idx
                AND dx.tree_id = t.tree_id AND dx.level_id > 100
                AND dx.prev_tags IS NOT NULL AND dx.prev_tags <> ''
            WHERE tms.next_ictv_id = tn.ictv_id
            ORDER BY tn.tree_id - dx.tree_id, dx.node_depth DESC
            LIMIT 1
        ) AS last_change_msl,
        
        IFNULL((
            SELECT CASE
                WHEN dx.prev_proposal IS NULL THEN ''
                WHEN dx.prev_proposal NOT LIKE '%;%' THEN CONCAT('=HYPERLINK("https://ictv.global/ictv/proposals/', dx.prev_proposal, '","', dx.prev_proposal, '")')
                WHEN dx.prev_proposal LIKE '%;%' THEN CONCAT('=HYPERLINK("https://ictv.global/ictv/proposals/', LEFT(dx.prev_proposal, INSTR(dx.prev_proposal, ';') - 1), '","', dx.prev_proposal, '")')
                ELSE ''
            END
            FROM taxonomy_node_merge_split tms
            JOIN taxonomy_node t ON
                t.ictv_id = tms.prev_ictv_id
                AND t.tree_id <= tn.tree_id
            JOIN taxonomy_node_dx dx ON
                dx.left_idx <= t.left_idx AND dx.right_idx >= t.right_idx
                AND dx.tree_id = t.tree_id AND dx.level_id > 100
                AND dx.prev_tags IS NOT NULL AND dx.prev_tags <> ''
            WHERE tms.next_ictv_id = tn.ictv_id
              AND dx.prev_proposal IS NOT NULL AND dx.prev_proposal <> ''
              AND dx.tree_id = (
                  SELECT dx2.tree_id
                  FROM taxonomy_node_merge_split tms2
                  JOIN taxonomy_node t2 ON
                      t2.ictv_id = tms2.prev_ictv_id
                      AND t2.tree_id <= tn.tree_id
                  JOIN taxonomy_node_dx dx2 ON
                      dx2.left_idx <= t2.left_idx AND dx2.right_idx >= t2.right_idx
                      AND dx2.tree_id = t2.tree_id AND dx2.level_id > 100
                      AND dx2.prev_tags IS NOT NULL AND dx2.prev_tags <> ''
                  WHERE tms2.next_ictv_id = tn.ictv_id
                  ORDER BY tn.tree_id - dx2.tree_id, dx2.node_depth DESC
                  LIMIT 1
              )
            ORDER BY tn.tree_id - dx.tree_id, dx.node_depth DESC
            LIMIT 1
        ), '') AS last_change_proposal,
        
        CONCAT('=HYPERLINK("https://ictv.global/taxonomy/taxondetails?taxnode_id=', tn.taxnode_id, '","ictv.global=', tn.taxnode_id, '")') AS history_url
    FROM taxonomy_node tn
    LEFT JOIN taxonomy_node `tree` ON `tree`.taxnode_id = tn.tree_id
    LEFT JOIN taxonomy_node `realm` ON `realm`.taxnode_id = tn.realm_id
    LEFT JOIN taxonomy_node `subrealm` ON `subrealm`.taxnode_id = tn.subrealm_id
    LEFT JOIN taxonomy_node `kingdom` ON `kingdom`.taxnode_id = tn.kingdom_id
    LEFT JOIN taxonomy_node `subkingdom` ON `subkingdom`.taxnode_id = tn.subkingdom_id
    LEFT JOIN taxonomy_node `phylum` ON `phylum`.taxnode_id = tn.phylum_id
    LEFT JOIN taxonomy_node `subphylum` ON `subphylum`.taxnode_id = tn.subphylum_id
    LEFT JOIN taxonomy_node `class` ON `class`.taxnode_id = tn.class_id
    LEFT JOIN taxonomy_node `subclass` ON `subclass`.taxnode_id = tn.subclass_id
    LEFT JOIN taxonomy_node `order` ON `order`.taxnode_id = tn.order_id
    LEFT JOIN taxonomy_node `suborder` ON `suborder`.taxnode_id = tn.suborder_id
    LEFT JOIN taxonomy_node `family` ON `family`.taxnode_id = tn.family_id
    LEFT JOIN taxonomy_node `subfamily` ON `subfamily`.taxnode_id = tn.subfamily_id
    LEFT JOIN taxonomy_node `genus` ON `genus`.taxnode_id = tn.genus_id
    LEFT JOIN taxonomy_node `subgenus` ON `subgenus`.taxnode_id = tn.subgenus_id
    LEFT JOIN taxonomy_node `species` ON `species`.taxnode_id = tn.species_id
    WHERE tn.is_deleted = 0 AND tn.is_hidden = 0 AND tn.is_obsolete = 0
      AND tn.tree_id = tree_id
      AND tn.level_id = 600 
      
      AND (taxnode_id IS NULL OR tn.taxnode_id = taxnode_id)
    ORDER BY tn.left_idx;

END
--------------

Query OK, 0 rows affected (0.009 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS QC_module_taxonomy_node_suffixes
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE QC_module_taxonomy_node_suffixes(IN filter VARCHAR(1000))
BEGIN
    




    SELECT
        'QC_module_taxonomy_node_suffixes' AS qc_module,
        src.*
    FROM (
        SELECT
            tn.msl_release_num,
            tn.left_idx,
            tn.tree_id,
            tn.taxnode_id,
            tn.name,
            tn.level_id,
            lvl.name AS `rank`,
            lvl.suffix,
            lvl.suffix_viroid,
            lvl.suffix_nuc_acid,
            lvl.suffix_viriform,
            CASE
                WHEN tn.name LIKE CONCAT('%', lvl.suffix) THEN CONCAT('OK: suffix = ', lvl.suffix)
                WHEN tn.name LIKE CONCAT('%', lvl.suffix_viroid) THEN CONCAT('OK: suffix_viriod = ', lvl.suffix_viroid)
                WHEN tn.name LIKE CONCAT('%', lvl.suffix_nuc_acid) THEN CONCAT('OK: suffix_nuc_acid = ', lvl.suffix_nuc_acid)
                WHEN tn.name LIKE CONCAT('%', lvl.suffix_viriform) THEN CONCAT('OK: suffix_viriform = ', lvl.suffix_viriform)
                WHEN tn.msl_release_num < 32 AND lvl.name IN ('genus') AND tn.name LIKE '%virus _' THEN 'OK: (historic pre-MSL32) "Influenza virus *" genus'
                WHEN tn.msl_release_num < 32 AND lvl.name IN ('genus') AND tn.name LIKE '%viruses' THEN 'OK: (historic pre-MSL32) "*viruses"'
                WHEN tn.msl_release_num < 32 AND lvl.name IN ('genus','family') AND tn.name LIKE '%phages' THEN 'OK: (historic pre-MSL32) "*phages"'
                WHEN tn.msl_release_num < 32 AND lvl.name IN ('genus') AND tn.name LIKE '%phage' THEN 'OK: (historic pre-MSL32) "*phage"'
                WHEN tn.msl_release_num < 32 AND lvl.name IN ('genus') AND tn.name LIKE '%genus%' THEN 'OK: (historic pre-MSL32) "*genus*"'
                WHEN tn.msl_release_num < 32 AND lvl.name IN ('family') AND tn.name LIKE '%family' THEN 'OK: (historic pre-MSL32) "*family"'
                WHEN tn.msl_release_num < 32 AND lvl.name IN ('genus','family') AND tn.name LIKE '%group%' THEN 'OK: (historic pre-MSL32) "*group*"'
                WHEN tn.msl_release_num < 32 AND lvl.name IN ('genus') AND tn.name LIKE '%viroids%' THEN 'OK: (historic pre-MSL32) "*viroids*"'
                WHEN tn.msl_release_num < 32 AND lvl.name IN ('family') AND tn.name LIKE '%viroids%' THEN 'OK: (historic pre-MSL32) "*viroids*"'
                WHEN tn.msl_release_num < 32 AND lvl.name IN ('genus') AND tn.name = 'Influenza virus A and B' THEN 'OK: (historic pre-MSL32) "Influenza virus A and B"'
                WHEN tn.msl_release_num < 32 AND lvl.name IN ('genus') AND tn.name = 'Lipid phage PM2' THEN 'OK: (historic pre-MSL32) "Lipid phage PM2"'
                WHEN tn.msl_release_num < 38 AND lvl.name IN ('genus') AND tn.name = 'Tunggulviirus' THEN 'OK: (historic pre-MSL38) "Tunggulviirus" (typo)'
                WHEN tn.msl_release_num < 38 AND lvl.name IN ('genus') AND tn.name = 'Incheonvrus' THEN 'OK: (historic pre-MSL38) "Incheonvrus" (typo)'
                ELSE 'ERROR: SUFFIX MISMATCH - look in taxonomy_level for legal suffix lists'
            END AS mesg
        FROM taxonomy_node tn
        JOIN taxonomy_level lvl ON lvl.id = tn.level_id
        WHERE tn.msl_release_num IS NOT NULL
          AND tn.name IS NOT NULL
          AND tn.name NOT IN ('Unassigned')
          AND lvl.suffix IS NOT NULL
    ) AS src
    WHERE src.mesg LIKE filter
    ORDER BY msl_release_num DESC, left_idx;

END
--------------

Query OK, 0 rows affected (0.006 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS QC_run_modules
--------------

Query OK, 0 rows affected (0.004 sec)

--------------
CREATE PROCEDURE QC_run_modules(IN module_filter VARCHAR(200))
BEGIN
    
    DECLARE done INT DEFAULT 0;
    DECLARE sp_name VARCHAR(200);
    DECLARE sql_statement TEXT;
    DECLARE v_filter VARCHAR(200);

    DECLARE qc_module_cursor CURSOR FOR
        SELECT ROUTINE_NAME
        FROM INFORMATION_SCHEMA.ROUTINES
        WHERE ROUTINE_TYPE = 'PROCEDURE'
          AND ROUTINE_SCHEMA = DATABASE()
          AND ROUTINE_NAME NOT LIKE 'dt_%'
          AND ROUTINE_NAME NOT LIKE 'sp_%diagram%'
          AND ROUTINE_NAME LIKE CONCAT(
                'QC_module_',
                IF(module_filter IS NULL OR module_filter = '', '%', module_filter),
                '%'
              )
        ORDER BY ROUTINE_NAME;

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    
    SET v_filter := IF(module_filter IS NULL OR module_filter = '', 'ERROR%', module_filter);

    OPEN qc_module_cursor;

    read_loop: LOOP
        FETCH qc_module_cursor INTO sp_name;
        IF done THEN
            LEAVE read_loop;
        END IF;

        
        IF sp_name = 'QC_module_taxonomy_node_ictv_resurrection' THEN
            SET sql_statement := CONCAT('CALL `', sp_name, '`(', QUOTE(v_filter), ', NULL)');
        ELSE
            
            SET sql_statement := CONCAT('CALL `', sp_name, '`(', QUOTE(v_filter), ')');
        END IF;

        
        SELECT CONCAT('SQL: ', sql_statement) AS debug_output;

        PREPARE stmt FROM sql_statement;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END LOOP read_loop;

    CLOSE qc_module_cursor;
END
--------------

Query OK, 0 rows affected (0.006 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS QC_module_ictv_id_deltas
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE QC_module_ictv_id_deltas
(
    IN p_filter VARCHAR(1000)   
)
BEGIN
    DECLARE v_current_msl INT;

    
    IF p_filter IS NULL THEN
        SET p_filter := 'ERROR%';
    END IF;

    
    SELECT MAX(msl_release_num) INTO v_current_msl
    FROM taxonomy_toc;

    
    SELECT
        'QC_module_ictv_id_deltas' AS qc_module,
        '[taxonomy_node_delta]'    AS table_name,

        
        ictvs.name,
        ictvs.ictv_id,
        ictvs.min_taxnode_id,
        ictvs.max_taxnode_id,
        ictvs.min_msl,
        ictvs.max_msl,
        ictvs.cur_msl,
        ictvs.is_msl_cur,
        ictvs.ct,
        ictvs.ct_prev,
        ictvs.ct_next,

        
        IFNULL(nd.tag_csv2,'') AS create_tags,
        CASE
          WHEN nd.is_new IS NULL THEN 'create_missing'
          WHEN IFNULL(nd.is_new,0) + IFNULL(nd.is_merged,0) + IFNULL(nd.is_split,0) = 0
               THEN 'create_wrong'
          ELSE ''
        END AS create_err,

        IFNULL(ed.tag_csv2,'') AS end_tags,
        CASE
          WHEN ictvs.cur_msl = ictvs.max_msl THEN ''
          WHEN ed.is_deleted IS NULL THEN 'end_missing'
          WHEN IFNULL(ed.is_deleted,0) + IFNULL(ed.is_merged,0) + IFNULL(ed.is_split,0) = 0
               THEN 'end_wrong'
          ELSE ''
        END AS end_err,

        TRIM(CONCAT(
          CASE
            WHEN ictvs.ct <> ictvs.ct_prev
                 THEN CONCAT('gap_prev:', CAST(ictvs.ct - ictvs.ct_prev AS CHAR))
            ELSE ''
          END,
          ' ',
          CASE
            WHEN ictvs.ct <> (ictvs.ct_next + ictvs.is_msl_cur)
                 THEN CONCAT('gap_next:', CAST(ictvs.ct - (ictvs.ct_next + ictvs.is_msl_cur) AS CHAR))
            ELSE ''
          END
        )) AS gap_err,

        
        CASE
          WHEN
            (CASE
               WHEN nd.is_new IS NULL THEN 'create_missing'
               WHEN IFNULL(nd.is_new,0) + IFNULL(nd.is_merged,0) + IFNULL(nd.is_split,0) = 0
                    THEN 'create_wrong'
               ELSE ''
             END) = ''
          AND
            (CASE
               WHEN ictvs.cur_msl = ictvs.max_msl THEN ''
               WHEN ed.is_deleted IS NULL THEN 'end_missing'
               WHEN IFNULL(ed.is_deleted,0) + IFNULL(ed.is_merged,0) + IFNULL(ed.is_split,0) = 0
                    THEN 'end_wrong'
               ELSE ''
             END) = ''
          AND
            TRIM(CONCAT(
              CASE
                WHEN ictvs.ct <> ictvs.ct_prev
                     THEN CONCAT('gap_prev:', CAST(ictvs.ct - ictvs.ct_prev AS CHAR))
                ELSE ''
              END,
              ' ',
              CASE
                WHEN ictvs.ct <> (ictvs.ct_next + ictvs.is_msl_cur)
                     THEN CONCAT('gap_next:', CAST(ictvs.ct - (ictvs.ct_next + ictvs.is_msl_cur) AS CHAR))
                ELSE ''
              END
            )) = ''
          THEN 'OK'
          ELSE CONCAT(
                 'ERROR: ',
                 (CASE
                    WHEN nd.is_new IS NULL THEN 'create_missing'
                    WHEN IFNULL(nd.is_new,0) + IFNULL(nd.is_merged,0) + IFNULL(nd.is_split,0) = 0
                         THEN 'create_wrong'
                    ELSE ''
                  END),
                 ' ',
                 (CASE
                    WHEN ictvs.cur_msl = ictvs.max_msl THEN ''
                    WHEN ed.is_deleted IS NULL THEN 'end_missing'
                    WHEN IFNULL(ed.is_deleted,0) + IFNULL(ed.is_merged,0) + IFNULL(ed.is_split,0) = 0
                         THEN 'end_wrong'
                    ELSE ''
                  END),
                 ' ',
                 TRIM(CONCAT(
                   CASE
                     WHEN ictvs.ct <> ictvs.ct_prev
                          THEN CONCAT('gap_prev:', CAST(ictvs.ct - ictvs.ct_prev AS CHAR))
                     ELSE ''
                   END,
                   ' ',
                   CASE
                     WHEN ictvs.ct <> (ictvs.ct_next + ictvs.is_msl_cur)
                          THEN CONCAT('gap_next:', CAST(ictvs.ct - (ictvs.ct_next + ictvs.is_msl_cur) AS CHAR))
                     ELSE ''
                   END
                 ))
               )
        END AS qc_mesg

    FROM
    (
      
      SELECT
        CONCAT(MIN(n.name),
               IF(MIN(n.name) <> MAX(n.name),
                    CONCAT(':', MAX(n.name)),
                    '')
             )                                    AS name,
        n.ictv_id,
        MIN(n.taxnode_id)                         AS min_taxnode_id,
        MAX(n.taxnode_id)                         AS max_taxnode_id,
        MIN(n.msl_release_num)                    AS min_msl,
        MAX(n.msl_release_num)                    AS max_msl,
        v_current_msl                             AS cur_msl,
        IF(v_current_msl = MAX(n.msl_release_num), 1, 0)
                                                 AS is_msl_cur,
        COUNT(DISTINCT n.taxnode_id)              AS ct,
        COUNT(DISTINCT nd_all.new_taxid)          AS ct_prev,
        COUNT(DISTINCT ed_all.prev_taxid)         AS ct_next
      FROM taxonomy_node AS n
      LEFT JOIN taxonomy_node_delta AS nd_all
             ON nd_all.new_taxid  = n.taxnode_id
      LEFT JOIN taxonomy_node_delta AS ed_all
             ON ed_all.prev_taxid = n.taxnode_id
      WHERE n.is_deleted       = 0
        AND n.is_obsolete      = 0
        AND n.msl_release_num IS NOT NULL
      GROUP BY n.ictv_id
    ) AS ictvs
    LEFT JOIN taxonomy_node_delta AS nd
           ON nd.new_taxid  = ictvs.min_taxnode_id
    LEFT JOIN taxonomy_node_delta AS ed
           ON ed.prev_taxid = ictvs.max_taxnode_id

    HAVING qc_mesg LIKE p_filter
    ORDER BY ictvs.ictv_id;

END
--------------

Query OK, 0 rows affected (0.007 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS QC_module_taxonomy_node_delta
--------------

Query OK, 0 rows affected (0.004 sec)

--------------
CREATE PROCEDURE QC_module_taxonomy_node_delta
(
    IN  p_filter VARCHAR(1000)   
)
BEGIN

    IF p_filter IS NULL THEN
        SET p_filter := 'ERROR%';
    END IF;
    
    WITH qc_src AS (
        
        SELECT
            'ERROR: new_taxid=NULL, but not an ABOLISH'            AS qc_mesg,
            d.msl,
            d.prev_taxid,
            n.ictv_id,
            d.new_taxid,
            d.tag_csv2,
            n.lineage,
            n.out_target                                            AS target
        FROM   taxonomy_node_delta AS d
        LEFT   JOIN taxonomy_node        AS n ON n.taxnode_id = d.prev_taxid
        WHERE  d.new_taxid IS NULL
          AND  d.is_deleted = 0

        UNION ALL

        
        SELECT
            'ERROR: prev_taxid=NULL, but not a NEW'                 AS qc_mesg,
            d.msl,
            d.prev_taxid,
            n.ictv_id,
            d.new_taxid,
            d.tag_csv2,
            n.lineage,
            n.in_target                                             AS target
        FROM   taxonomy_node_delta AS d
        LEFT   JOIN taxonomy_node        AS n ON n.taxnode_id = d.new_taxid
        WHERE  d.prev_taxid IS NULL
          AND  d.is_new = 0
    )

    
    SELECT
        'QC_module_taxonomy_node_delta'         AS qc_module,
        '[taxonomy_node_delta]'                 AS table_name,
        qs.*
    FROM   qc_src AS qs
    WHERE  qs.qc_mesg LIKE p_filter
    ORDER  BY qs.msl DESC,
              qs.lineage,
              qs.qc_mesg;
END
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS QC_module_taxonomy_node_hidden_nodes
--------------

Query OK, 0 rows affected (0.007 sec)

--------------
CREATE PROCEDURE QC_module_taxonomy_node_hidden_nodes
(
    IN p_filter VARCHAR(1000)          
)
BEGIN
    
    IF p_filter IS NULL THEN
        SET p_filter := 'ERROR%';
    END IF;

    
    SELECT
        'QC_module_taxonomy_node_hidden_nodes' AS qc_module,   
        '[taxonomy_node]'                      AS table_name,
        src.msl_release_num                    AS msl,
        src.taxnode_id,
        src.left_idx,
        src.rank,
        src.name,
        src.is_hidden,
        src.is_deleted,
        src.is_typo,
        src.is_obsolete,
        src.notes,
        
        CASE
            WHEN src.errors = '' THEN 'OK'
            ELSE CONCAT('ERROR:', src.errors)
        END                                              AS qc_mesg
    FROM
    (
        
        SELECT
            n.msl_release_num,
            n.taxnode_id,
            n.left_idx,
            r.name                                            AS rank,
            n.name,
            n.is_hidden,
            n.is_deleted,
            n.is_typo,
            n.is_obsolete,
            n.notes,
            
            CASE
                WHEN n.is_hidden = 1
                     AND n.level_id <> 100
                     AND (n.is_deleted + n.is_typo + n.is_obsolete) = 0
                THEN CONCAT('HIDDEN[', r.name, ':', n.name, '];')
                ELSE ''
            END                                              AS errors
        FROM taxonomy_node  AS n
        JOIN taxonomy_level AS r  ON r.id = n.level_id
        WHERE n.msl_release_num IS NOT NULL
    ) AS src
    
    WHERE (CASE
               WHEN src.errors = '' THEN 'OK'
               ELSE CONCAT('ERROR:', src.errors)
           END) LIKE p_filter
    ORDER BY src.msl_release_num DESC,
             src.left_idx,
             qc_mesg;
END
--------------

Query OK, 0 rows affected (0.005 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS QC_module_taxonomy_node_ictv_resurrection
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE QC_module_taxonomy_node_ictv_resurrection(
    IN  p_filter      VARCHAR(1000),   
    IN  p_target_name VARCHAR(100)     
)
BEGIN
    
    IF p_filter IS NULL THEN
        SET p_filter := 'ERROR%';
    END IF;

    
    SELECT
      'QC_module_taxonomy_node_ictv_resurrection' AS qc_module,
      '[taxonomy_node]'                            AS table_name,
      pairs_core.*,
      
      CONCAT_WS(
        '',
        CASE
          WHEN pairs_core.p_name COLLATE utf8mb4_bin = pairs_core.n_name COLLATE utf8mb4_bin
            THEN ''
          ELSE 'WARNING: CASE; '
        END,
        CASE
          WHEN pairs_core.link_ct = 0
            THEN 'ERROR: NOT LINKED;'
          WHEN pairs_core.link_ct = 1
           AND pairs_core.p_out_change = 'abolish'
           AND pairs_core.n_in_change  = 'new'
            THEN 'OK: linked new:abolish/new:...'
          WHEN pairs_core.link_ct = 1
            THEN CONCAT(
                   'WARNING: linked, but ',
                   IFNULL(pairs_core.p_out_change,'NULL'), ':',
                   IFNULL(pairs_core.n_in_change,'NULL')
                 )
          WHEN pairs_core.link_ct > 1
            THEN 'ERROR: link_ct > 1'
          ELSE 'ERROR: unknown'
        END
      ) AS qc_mesg
    FROM (
      
      SELECT
          
          src.level_id,
          src.name,
          src.ictv_ct,

          
          prev_range.ictv_id        AS p_ictv_id,
          prev_range.min_msl        AS p_min_msl,
          prev_range.max_msl        AS p_max_msl,
          prev_range.min_taxnode_id AS p_min_taxnode_id,
          prev_range.max_taxnode_id AS p_max_taxnode_id,
          pc.name                   AS p_name,
          pc.out_change             AS p_out_change,

          
          CASE
            WHEN prev_range.max_msl = next_range.min_msl + 1 THEN '>>ADJ>>'
            ELSE '>>GAP>>'
          END                       AS s2,

          
          (
            SELECT CONCAT(
                     COUNT(*), ':',
                     IFNULL(MAX(CONCAT(d.tag_csv2, IFNULL(CONCAT(':', d.proposal), ''))), '')
                   )
            FROM taxonomy_node_delta d
            WHERE d.new_taxid = next_range.min_taxnode_id
          ) AS prevDELTAs,

          
          next_range.ictv_id        AS n_ictv_id,
          next_range.min_msl        AS n_min_msl,
          next_range.max_msl        AS n_max_msl,
          next_range.min_taxnode_id AS n_min_taxnode_id,
          next_range.max_taxnode_id AS n_max_taxnode_id,
          nc.name                   AS n_name,
          nc.in_change              AS n_in_change,

          
          (
            SELECT COUNT(*)
            FROM taxonomy_node_merge_split ms
            WHERE ms.prev_ictv_id = prev_range.ictv_id
              AND ms.next_ictv_id = next_range.ictv_id
          ) AS link_ct

      FROM (
          
          SELECT
              n.level_id,
              n.name,
              COUNT(DISTINCT n.ictv_id) AS ictv_ct
          FROM taxonomy_node AS n
          WHERE n.name = IFNULL(p_target_name, n.name)
            AND n.name <> 'Unnamed genus'
          GROUP BY n.level_id, n.name
          HAVING COUNT(DISTINCT n.ictv_id) > 1
      ) AS src

      
      JOIN (
          SELECT
              n.level_id, n.name, n.ictv_id,
              MIN(n.msl_release_num) AS min_msl,
              MAX(n.msl_release_num) AS max_msl,
              MIN(n.taxnode_id)      AS min_taxnode_id,
              MAX(n.taxnode_id)      AS max_taxnode_id
          FROM taxonomy_node AS n
          GROUP BY n.level_id, n.ictv_id, n.name
      ) AS prev_range
        ON prev_range.level_id = src.level_id
       AND prev_range.name     = src.name

      JOIN taxonomy_node AS pc
        ON pc.taxnode_id = prev_range.max_taxnode_id

      
      LEFT JOIN (
          SELECT
              n.level_id, n.name, n.ictv_id,
              MIN(n.msl_release_num) AS min_msl,
              MAX(n.msl_release_num) AS max_msl,
              MIN(n.taxnode_id)      AS min_taxnode_id,
              MAX(n.taxnode_id)      AS max_taxnode_id
          FROM taxonomy_node AS n
          GROUP BY n.level_id, n.ictv_id, n.name
      ) AS next_range
        ON next_range.level_id = src.level_id
       AND next_range.name     = src.name

      LEFT JOIN taxonomy_node AS nc
        ON nc.taxnode_id = next_range.min_taxnode_id

      
      WHERE prev_range.max_msl < next_range.min_msl
    ) AS pairs_core
    HAVING qc_mesg LIKE p_filter
       AND pairs_core.name LIKE IFNULL(p_target_name, pairs_core.name)
    ORDER BY
      pairs_core.name,
      pairs_core.p_min_msl, pairs_core.p_max_msl,
      pairs_core.n_min_msl, pairs_core.n_max_msl;

END
--------------

Query OK, 0 rows affected (0.007 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS QC_module_taxonomy_node_orphan_taxa
--------------

Query OK, 0 rows affected (0.004 sec)

--------------
CREATE PROCEDURE QC_module_taxonomy_node_orphan_taxa
(
    IN p_filter VARCHAR(1000)        
)
BEGIN
    
    IF p_filter IS NULL THEN
        SET p_filter := 'ERROR%';
    END IF;

    
    SELECT
        'QC_module_taxonomy_node_orphan_taxa'   AS qc_module,     
        src.msl_release_num,
        src.taxnode_id,
        src.name,
        src.level_id,
        src.left_idx,
        src.right_idx,
        src.parent_id,
        src.parent_name,
        src.rank,
        src.mesg
    FROM
    (
        SELECT
              tn.msl_release_num,
              tn.taxnode_id,
              tn.name,
              tn.level_id,
              tn.left_idx,
              tn.right_idx,
              tn.parent_id,
              p.name                                          AS parent_name,
              lvl.name                                        AS rank,
              
              CASE
                  WHEN tn.left_idx  IS NULL THEN 'ERROR: left_idx = NULL'
                  WHEN tn.right_idx IS NULL THEN 'ERROR: right_idx = NULL'
                  ELSE 'OK: left and right idx'
              END                                             AS mesg
        FROM taxonomy_node  AS tn
        JOIN taxonomy_level AS lvl ON lvl.id = tn.level_id
        LEFT JOIN taxonomy_node AS p ON p.taxnode_id = tn.parent_id
        WHERE tn.msl_release_num IS NOT NULL
    ) AS src
    WHERE src.mesg LIKE p_filter
    ORDER BY src.msl_release_num DESC,
             src.left_idx;
END
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS QC_module_virus_prop_tabs
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE QC_module_virus_prop_tabs
(
    IN p_filter VARCHAR(1000)     
)
BEGIN
    
    IF p_filter IS NULL THEN
        SET p_filter := 'ERROR%';
    END IF;

    
    SELECT
        'QC_module_virus_prop_tabs'           AS qc_module,      
        '[virus_prop]'                        AS table_name,
        vp.taxon                              AS taxon,
        
        CASE
            WHEN errs = ''  THEN 'OK'
            ELSE CONCAT('ERROR:', errs)
        END                                    AS qc_mesg
    FROM
    (
        
        SELECT
            taxon,
            CONCAT(
                IF(taxon                LIKE CONCAT('%',CHAR(9),'%'),'TAB[taxon];', ''),
                IF(sub_taxon            LIKE CONCAT('%',CHAR(9),'%'),'TAB[sub_taxon];', ''),
                IF(molecule             LIKE CONCAT('%',CHAR(9),'%'),'TAB[molecule];', ''),
                IF(morphology           LIKE CONCAT('%',CHAR(9),'%'),'TAB[morphology];', ''),
                IF(virion_size          LIKE CONCAT('%',CHAR(9),'%'),'TAB[virion_size];', ''),
                IF(genome_segments      LIKE CONCAT('%',CHAR(9),'%'),'TAB[genome_segments];', ''),
                IF(genome_configuration LIKE CONCAT('%',CHAR(9),'%'),'TAB[genome_configuration];', ''),
                IF(genome_size          LIKE CONCAT('%',CHAR(9),'%'),'TAB[genome_size];', ''),
                IF(host                 LIKE CONCAT('%',CHAR(9),'%'),
                       CONCAT('TAB[host]=', REPLACE(host, CHAR(9), '[TAB]')),
                       '')
            ) AS errs
        FROM virus_prop
    ) AS vp
    
    WHERE
        CASE
            WHEN errs = '' THEN 'OK'
            ELSE CONCAT('ERROR:', errs)
        END LIKE p_filter
    ORDER BY qc_mesg;
END
--------------

Query OK, 0 rows affected (0.005 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS QC_module_vmr_export_species_count
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE QC_module_vmr_export_species_count
(
    IN p_filter VARCHAR(1000)   
)
BEGIN
    DECLARE v_curr_msl INT;
    
    IF p_filter IS NULL THEN
        SET p_filter := 'ERROR%';
    END IF;

    
    SELECT MAX(msl_release_num) INTO v_curr_msl FROM taxonomy_toc;

    
    SELECT
        'QC_module_vmr_export_species_count'  AS qc_module,    
        '[vmr_export]'                        AS table_name,
        t.*                                                    
    FROM
    (
        
        SELECT
              'ERROR: species missing from [vmr_export]' AS qc_mesg,
              n.msl_release_num,
              n.lineage,
              1 AS ct
        FROM taxonomy_node AS n
        WHERE n.msl_release_num = v_curr_msl
          AND n.level_id = 600
          AND n.name NOT IN (SELECT `species` FROM vmr_export)

        UNION ALL

        
        SELECT
              'ERROR: extra species in [vmr_export] (missing from taxonomy_node)' AS qc_mesg,
              v_curr_msl                                          AS msl_release_num,
              vmr.`species`                                       AS lineage,
              1                                                   AS ct
        FROM vmr_export AS vmr
        WHERE vmr.`species` NOT IN (
                SELECT name
                FROM taxonomy_node
                WHERE msl_release_num = v_curr_msl
                  AND level_id = 600
        )

        UNION ALL

        
        SELECT
              'ERROR: too many/too few E records  in [vmr_export]' AS qc_mesg,
              v_curr_msl                          AS msl_release_num,
              vmr.`species`                       AS lineage,
              COUNT(*)                            AS ct
        FROM vmr_export AS vmr
        GROUP BY vmr.`species`
        HAVING
            1 <> COUNT(CASE WHEN `Exemplar or additional isolate` = 'E' THEN 1 END)

        UNION ALL

        
        SELECT
              'ERROR: two isolates have same accession [vmr_export]' AS qc_mesg,
              v_curr_msl                          AS msl_release_num,
              CASE
                  WHEN vmr.`Virus GENBANK accession` = ''
                       THEN 'MSL40: no accession; N=151'
                  ELSE CONCAT(
                          vmr.`Virus GENBANK accession`,
                          ' [',
                          MIN(CONCAT(`Species`,':',`Exemplar or additional isolate`,':',`Virus name(s)`)),
                          ' | ',
                          MAX(CONCAT(`Species`,':',`Exemplar or additional isolate`,':',`Virus name(s)`)),
                          ']'
                       )
              END                                    AS lineage,
              COUNT(*)                              AS ct
        FROM vmr_export AS vmr
        GROUP BY vmr.`Virus GENBANK accession`
        HAVING COUNT(*) > 1

        UNION ALL

        
        SELECT
              'ERROR: E record is not isolate_sort=1 [vmr_export]' AS qc_mesg,
              v_curr_msl                          AS msl_release_num,
              vmr.`Species`                       AS lineage,
              COUNT(*)                            AS ct
        FROM vmr_export AS vmr
        WHERE vmr.`Isolate Sort` <> 1
          AND vmr.`Exemplar or additional isolate` = 'E'
        GROUP BY vmr.`Species`

        UNION ALL

        
        SELECT
              'ERROR: NULL isolate_sort [vmr_export]' AS qc_mesg,
              v_curr_msl                          AS msl_release_num,
              vmr.`Species`                       AS lineage,
              COUNT(*)                            AS ct
        FROM vmr_export AS vmr
        WHERE vmr.`Isolate Sort` IS NULL
        GROUP BY vmr.`Species`
    ) AS t
    
    WHERE t.qc_mesg LIKE p_filter
    ORDER BY t.msl_release_num DESC, t.qc_mesg, t.lineage;
END
--------------

Query OK, 0 rows affected (0.006 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS rebuild_delta_nodes
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE rebuild_delta_nodes
(
    IN  p_msl         INT,
    IN  p_debug_taxid INT,
    IN  p_debug_notes VARCHAR(20)
)
BEGIN
    
    IF p_msl IS NULL THEN
        SELECT MAX(msl_release_num) INTO p_msl FROM taxonomy_node;
    END IF;

    
    DELETE FROM taxonomy_node_delta
     WHERE msl = p_msl;

    
    INSERT INTO taxonomy_node_delta
        ( msl, prev_taxid, new_taxid, proposal, notes,
          is_new, is_split,
          is_now_type, is_promoted, is_demoted )
    SELECT
        n.msl_release_num                                           AS msl,
        p.taxnode_id,
        n.taxnode_id,
        n.in_filename                                               AS proposal,
        CONCAT_WS('', IFNULL(CONCAT('[',p_debug_notes,'NEW/SPLIT];'),''), n.in_notes)  AS notes,
        (n.in_change='new')                                         AS is_new,
        (n.in_change='split')                                       AS is_split,
        CASE
            WHEN p.is_ref=1  AND n.is_ref=0 THEN -1
            WHEN p.is_ref=0  AND n.is_ref=1 THEN  1
            ELSE 0
        END                                                         AS is_now_type,
        IF(p.level_id IS NOT NULL AND n.level_id IS NOT NULL AND p.level_id > n.level_id, 1, 0) AS is_promoted,
        IF(p.level_id IS NOT NULL AND n.level_id IS NOT NULL AND p.level_id < n.level_id, 1, 0) AS is_demoted
        
        
    FROM taxonomy_node AS n
    LEFT JOIN taxonomy_node AS p  ON p.msl_release_num = n.msl_release_num-1
                                 AND n.in_target COLLATE utf8mb4_bin IN (p.lineage, p.name)
    LEFT JOIN taxonomy_node_delta d ON d.new_taxid = n.taxnode_id
    WHERE n.in_change IN ('new','split')
      AND d.new_taxid IS NULL
      AND n.msl_release_num = p_msl
      AND n.is_deleted      = 0
      AND (p_debug_taxid IS NULL OR n.taxnode_id = p_debug_taxid);
    

    
    INSERT INTO taxonomy_node_delta
        ( msl, prev_taxid, new_taxid, proposal, notes,
          is_renamed, is_merged, is_lineage_updated,
          is_promoted, is_demoted, is_now_type, is_deleted )
    SELECT
        s.msl,
        s.prev_taxid,
        s.new_taxid,
        s.proposal,
        CONCAT_WS('', IFNULL(CONCAT('[',p_debug_notes,'RENAME,MERGE,PROMOTE,MOVE,ABOLISH];'),''), s.notes),
        IF(
            next_msl.name IS NOT NULL
            AND prev_msl.name IS NOT NULL
            AND prev_msl.name <> next_msl.name COLLATE utf8mb4_bin
            AND COALESCE(s.is_merged,0) = 0,
            1, 0
        ) AS is_renamed,
        
        
        s.is_merged,
        IF(
            next_pmsl.lineage IS NOT NULL
            AND prev_pmsl.lineage IS NOT NULL
            AND prev_pmsl.lineage <> next_pmsl.lineage COLLATE utf8mb4_bin
            AND (prev_pmsl.level_id<>100 OR next_pmsl.level_id<>100),
            1, 0
        ) AS is_lineage_updated,
        
        
         IF(next_msl.level_id IS NOT NULL AND prev_msl.level_id > next_msl.level_id, 1, 0) AS is_promoted,
         IF(next_msl.level_id IS NOT NULL AND prev_msl.level_id < next_msl.level_id, 1, 0) AS is_demoted,

        
        
        CASE
            WHEN prev_msl.is_ref=1 AND next_msl.is_ref=0 THEN -1
            WHEN prev_msl.is_ref=0 AND next_msl.is_ref=1 THEN  1
            ELSE 0
        END                                                         AS is_now_type,
        s.is_abolish
    FROM (
        
        SELECT DISTINCT
            p.msl_release_num+1   AS msl,
            p.taxnode_id          AS prev_taxid,
            
            CASE
              WHEN p.out_change <> 'promote'
               AND p.level_id > targ.level_id
               AND targ_child.taxnode_id IS NOT NULL
                   THEN targ_child.taxnode_id
              WHEN p.level_id=500 AND targ.level_id=600
               AND p.name <> 'Unassigned'
                   THEN targ.parent_id
              ELSE targ.taxnode_id
            END                AS new_taxid,
            p.out_filename     AS proposal,
            CAST(p.out_notes AS CHAR) AS notes,
            (p.out_change='merge')  AS is_merged,
            (p.out_change='abolish') AS is_abolish
        FROM taxonomy_node            p
        LEFT JOIN taxonomy_node       targ
              ON targ.msl_release_num = p.msl_release_num+1
             AND (p.out_target COLLATE utf8mb4_bin IN (targ.lineage,targ.name)
                  OR p._out_target_name COLLATE utf8mb4_bin = targ.name)
             AND p.is_deleted = 0
        LEFT JOIN taxonomy_node targ_child
              ON targ_child.parent_id = targ.taxnode_id
             AND (targ_child.name = p.name COLLATE utf8mb4_bin
                  OR targ_child.name = p.out_target COLLATE utf8mb4_bin)
             AND targ_child.level_id = p.level_id
             AND p.out_change <> 'promote'
             AND targ_child.name <> 'Unassigned'
             AND targ_child.is_hidden = 0
        LEFT JOIN taxonomy_node_delta d
              ON d.prev_taxid = p.taxnode_id
        WHERE p.out_change IS NOT NULL
          AND p.msl_release_num = p_msl-1
          AND d.prev_taxid IS NULL
    ) AS s
    JOIN taxonomy_node prev_msl  ON prev_msl.taxnode_id = s.prev_taxid
    JOIN taxonomy_node prev_pmsl ON prev_pmsl.taxnode_id = prev_msl.parent_id
    LEFT JOIN taxonomy_node next_msl  ON next_msl.taxnode_id = s.new_taxid
    LEFT JOIN taxonomy_node next_pmsl ON next_pmsl.taxnode_id = next_msl.parent_id
    WHERE (p_debug_taxid IS NULL OR s.new_taxid = p_debug_taxid);
    

    
    INSERT INTO taxonomy_node_delta
        (msl, prev_taxid, new_taxid, proposal, notes,
         is_lineage_updated, is_promoted, is_demoted, is_now_type)
    SELECT
        n.msl_release_num,
        p.taxnode_id,
        n.taxnode_id,
        p.out_filename,
        CONCAT_WS('', IFNULL(CONCAT('[',p_debug_notes,'NO CHANGE];'),''), p.out_notes),
        (pp.lineage <> pn.lineage COLLATE utf8mb4_bin
         AND pp.level_id<>100)                              AS is_lineage_updated,
         IF(p.level_id IS NOT NULL AND n.level_id IS NOT NULL AND p.level_id > n.level_id, 1, 0) AS is_promoted,
         IF(p.level_id IS NOT NULL AND n.level_id IS NOT NULL AND p.level_id < n.level_id, 1, 0) AS is_demoted,
        
        
        CASE
          WHEN p.is_ref=1 AND n.is_ref=0 THEN -1
          WHEN p.is_ref=0 AND n.is_ref=1 THEN  1
          ELSE 0
        END                                                 AS is_now_type
    FROM taxonomy_node p
    JOIN taxonomy_node n
         ON n.msl_release_num = p.msl_release_num+1
        AND ( n.lineage = p.lineage
           OR (n.name = p.name COLLATE utf8mb4_bin
               AND n.name<>'Unassigned' AND n.level_id=p.level_id)
           OR (n.level_id=100 AND p.level_id=100) )
    LEFT JOIN taxonomy_node_delta pd
         ON pd.prev_taxid = p.taxnode_id
        AND pd.is_split  = 0
    LEFT JOIN taxonomy_node_delta nd
         ON nd.new_taxid = n.taxnode_id
        AND nd.is_merged = 0
    JOIN taxonomy_node pp ON pp.taxnode_id = p.parent_id
    JOIN taxonomy_node pn ON pn.taxnode_id = n.parent_id
    WHERE n.msl_release_num = p_msl
      AND pd.prev_taxid IS NULL
      AND nd.new_taxid IS NULL
      AND p.is_deleted = 0
      AND n.is_deleted = 0
      AND (p_debug_taxid IS NULL OR n.taxnode_id = p_debug_taxid);
    

    

    UPDATE taxonomy_node_delta AS d
    LEFT JOIN taxonomy_node_names prev_node  ON prev_node.taxnode_id = d.prev_taxid
    LEFT JOIN taxonomy_node       prev_parent ON prev_parent.taxnode_id = prev_node.parent_id
    LEFT JOIN taxonomy_node_names next_node  ON next_node.taxnode_id = d.new_taxid
    LEFT JOIN taxonomy_node       next_parent ON next_parent.taxnode_id = next_node.parent_id
    LEFT JOIN taxonomy_node_delta parent_delta
        ON parent_delta.prev_taxid = prev_parent.taxnode_id
        AND parent_delta.new_taxid  = next_parent.taxnode_id
    SET
    d.is_moved =
        (
        IF(prev_parent.ictv_id IS NOT NULL AND next_parent.ictv_id IS NOT NULL
            AND prev_parent.ictv_id <> next_parent.ictv_id, 1, 0)
        * IF(COALESCE(prev_node.out_change, '') NOT LIKE '%promot%', 1, 0)
        * IF(COALESCE(prev_node.out_change, '') NOT LIKE '%demot%', 1, 0)
        * IF(COALESCE(parent_delta.is_merged, 0) = 1, 0, 1)
        * IF(COALESCE(parent_delta.is_split, 0) = 1,
            IF(prev_parent.ictv_id IS NOT NULL AND next_parent.ictv_id IS NOT NULL
                AND prev_parent.ictv_id <> next_parent.ictv_id, 1, 0),
            1)
        * IF(prev_parent.level_id = 100 AND next_parent.level_id = 100, 0, 1)
        ),
    d.notes = IF(
        (
            IF(prev_parent.ictv_id IS NOT NULL AND next_parent.ictv_id IS NOT NULL
            AND prev_parent.ictv_id <> next_parent.ictv_id, 1, 0)
        * IF(COALESCE(prev_node.out_change, '') NOT LIKE '%promot%', 1, 0)
        * IF(COALESCE(prev_node.out_change, '') NOT LIKE '%demot%', 1, 0)
        * IF(COALESCE(parent_delta.is_merged, 0) = 1, 0, 1)
        * IF(COALESCE(parent_delta.is_split, 0) = 1,
            IF(prev_parent.ictv_id IS NOT NULL AND next_parent.ictv_id IS NOT NULL
                AND prev_parent.ictv_id <> next_parent.ictv_id, 1, 0),
            1)
        * IF(prev_parent.level_id = 100 AND next_parent.level_id = 100, 0, 1)
        ) = 1,
        CONCAT('[',p_debug_notes,'SET MOVED=1];', d.notes),
        d.notes
        )
    WHERE prev_node.msl_release_num + 1 = p_msl;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    UPDATE taxonomy_node_delta AS d
    JOIN (
       SELECT new_taxid
       FROM taxonomy_node_delta
       WHERE msl = p_msl
       GROUP BY new_taxid
       HAVING COUNT(*) > 1
    ) AS msrc USING (new_taxid)
    SET d.is_merged  = 1,
        d.is_renamed = 0,
        d.proposal   = (SELECT MAX(p2.proposal)
                        FROM taxonomy_node_delta p2
                        WHERE p2.msl=p_msl AND p2.new_taxid=msrc.new_taxid),
        d.notes      = CONCAT('[',p_debug_notes,'UPGRADE_TO_MERGE];', d.notes)
    WHERE d.msl = p_msl
      AND d.is_merged = 0;

END
--------------

Query OK, 0 rows affected (0.009 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS searchTaxonomy
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE searchTaxonomy(
    IN currentMslRelease INT,
    IN includeAllReleases BOOLEAN,
    IN searchText NVARCHAR(100),
    IN selectedMslRelease INT
)
BEGIN
    
    DECLARE filteredSearchText VARCHAR(100);
    DECLARE trimmedSearchText NVARCHAR(100);

    
    IF currentMslRelease IS NULL OR currentMslRelease < 1 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Please enter a valid current MSL release';
    END IF;

    
    SET trimmedSearchText = TRIM(searchText);
    IF trimmedSearchText IS NULL OR CHAR_LENGTH(trimmedSearchText) < 1 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Please enter non-empty search text';
    END IF;

    
    SET filteredSearchText = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
        trimmedSearchText,
        'í','i'),'é','e'),'ó','o'),'ú','u'),'á','a'),'ì','i'),'è','e'),'ò','o'),'ù','u'),'à','a'),'î','i'),'ê','e'),'ô','o'),'û','u'),'â','a'),'ü','u'),'ö','o'),'ï','i'),'ë','e'),'ä','a'),'ç','c'),'ñ','n'),'‘',''''),'’',''''),'`',' '),'  ',' '),'ā','a'),'ī','i'),'ĭ','i'),'ǎ','a'),'ē','e'),'ō','o');

    
    IF includeAllReleases IS NULL THEN
        SET includeAllReleases = FALSE;
    END IF;

    
    IF includeAllReleases = FALSE AND selectedMslRelease IS NULL THEN
        SET selectedMslRelease = currentMslRelease;
    END IF;

    
    
    

    WITH base AS (
    SELECT
        tn.taxnode_id, tn.parent_id, tn.level_id, tn.left_idx, tn.tree_id,
        tn.ictv_id, tn.lineage, tn.msl_release_num,
        tl.name  AS rank_name,
        tree.name AS tree_name,
        CONCAT(
            tn.tree_id,
            IF(tn.realm_id      IS NOT NULL, CONCAT(',', tn.realm_id), ''),
            IF(tn.subrealm_id   IS NOT NULL, CONCAT(',', tn.subrealm_id), ''),
            IF(tn.kingdom_id    IS NOT NULL, CONCAT(',', tn.kingdom_id), ''),
            IF(tn.subkingdom_id IS NOT NULL, CONCAT(',', tn.subkingdom_id), ''),
            IF(tn.phylum_id     IS NOT NULL, CONCAT(',', tn.phylum_id), ''),
            IF(tn.subphylum_id  IS NOT NULL, CONCAT(',', tn.subphylum_id), ''),
            IF(tn.class_id      IS NOT NULL, CONCAT(',', tn.class_id), ''),
            IF(tn.subclass_id   IS NOT NULL, CONCAT(',', tn.subclass_id), ''),
            IF(tn.order_id      IS NOT NULL, CONCAT(',', tn.order_id), ''),
            IF(tn.suborder_id   IS NOT NULL, CONCAT(',', tn.suborder_id), ''),
            IF(tn.family_id     IS NOT NULL, CONCAT(',', tn.family_id), ''),
            IF(tn.subfamily_id  IS NOT NULL, CONCAT(',', tn.subfamily_id), ''),
            IF(tn.genus_id      IS NOT NULL, CONCAT(',', tn.genus_id), ''),
            IF(tn.subgenus_id   IS NOT NULL, CONCAT(',', tn.subgenus_id), ''),
            IF(tn.species_id    IS NOT NULL, CONCAT(',', tn.species_id), '')
        ) AS taxnode_lineage
    FROM taxonomy_node tn FORCE INDEX (idx_tn_allreleases_order)
    JOIN taxonomy_level tl  ON tl.id = tn.level_id
    JOIN taxonomy_node tree ON tree.taxnode_id = tn.tree_id
    WHERE
        tn.taxnode_id <> tn.tree_id
        AND tn.is_hidden = 0
        AND tn.is_deleted = 0
        AND tn.msl_release_num <= currentMslRelease
        AND (includeAllReleases OR tn.msl_release_num = COALESCE(selectedMslRelease, currentMslRelease))
        AND tn.cleaned_name LIKE CONCAT('%', filteredSearchText, '%')
    ),
    parents AS (
    SELECT DISTINCT parent_id, level_id
    FROM base
    ),
    sibs AS (
    SELECT
        n.taxnode_id,
        DENSE_RANK() OVER (
            PARTITION BY n.parent_id, n.level_id
            ORDER BY n.left_idx, n.taxnode_id
        ) AS display_order
    FROM taxonomy_node n
    JOIN parents p
        ON p.parent_id = n.parent_id
    AND p.level_id  = n.level_id
    WHERE
        n.taxnode_id <> n.tree_id
    )
    SELECT
    s.display_order,
    b.ictv_id,
    REPLACE(IFNULL(b.lineage,''), ';', '>') AS lineage,
    b.parent_id AS parent_taxnode_id,
    b.rank_name,
    b.msl_release_num AS release_number,
    searchText AS search_text,
    b.taxnode_id,
    b.taxnode_lineage,
    b.tree_id,
    b.tree_name
    FROM base b
    JOIN sibs s ON s.taxnode_id = b.taxnode_id
    ORDER BY b.tree_id DESC, b.left_idx;

END
--------------

Query OK, 0 rows affected (0.007 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS sp_simplify_molecule_id_settings
--------------

Query OK, 0 rows affected (0.004 sec)

--------------
CREATE PROCEDURE sp_simplify_molecule_id_settings(
    IN in_msl INT
)
BEGIN
    DECLARE current_msl INT;
    DECLARE tree_id INT;
    DECLARE affected_rows INT;

    
    IF in_msl IS NULL OR in_msl < 1 THEN
        SET current_msl = udf_getMSL(NULL);
    ELSE
        SET current_msl = in_msl;
    END IF;

    SELECT MAX(tree_id), MAX(msl_release_num) INTO tree_id, current_msl
    FROM taxonomy_toc
    WHERE tree_id = current_msl 
       OR msl_release_num = current_msl 
       OR (msl_release_num IS NOT NULL AND in_msl IS NULL);

    SELECT CONCAT('TARGET MSL=', current_msl, ' TARGET TREE=', tree_id) AS debug_info;

    
    loop1: WHILE 1=1 DO
        UPDATE taxonomy_node tn
        JOIN (
            SELECT 
                t.left_idx, t.taxnode_id, t.`rank`, t.lineage, t.molecule_id, t.inher_molecule_id,
                COUNT(n.taxnode_id) AS n_ct, COUNT(n.inher_molecule_id) AS im_ct,
                MIN(n.inher_molecule) AS im_min, MAX(n.inher_molecule) AS im_max,
                MIN(n.inher_molecule_id) AS consensus_mol_id
            FROM taxonomy_node_names t
            JOIN taxonomy_node_names n ON n.left_idx BETWEEN t.left_idx AND t.right_idx 
                                       AND n.tree_id = t.tree_id 
                                       AND n.taxnode_id <> t.taxnode_id
            WHERE t.msl_release_num = current_msl 
              AND (
                    (t.level_id >= 200 AND (t.`order` <> 'Bunyavirales' OR t.`order` IS NULL))
                    OR
                    (t.level_id >= 500 AND t.`order` = 'Bunyavirales')
                  )
            GROUP BY t.left_idx, t.taxnode_id, t.`rank`, t.lineage, t.molecule_id, t.inher_molecule_id
            HAVING COUNT(n.taxnode_id) = COUNT(n.inher_molecule_id)
              AND MIN(n.inher_molecule_id) = MAX(n.inher_molecule_id)
              AND (
                   t.molecule_id IS NULL
                   AND (
                        t.inher_molecule_id IS NULL
                        OR t.inher_molecule_id <> MIN(n.inher_molecule_id)
                      )
                  )
            ORDER BY t.left_idx
            LIMIT 1000000
        ) AS src ON src.taxnode_id = tn.taxnode_id
        SET tn.molecule_id = src.consensus_mol_id;

        SET affected_rows = ROW_COUNT();
        IF affected_rows = 0 THEN
            LEAVE loop1;
        END IF;
    END WHILE loop1;

    
    loop2: WHILE 1=1 DO
        UPDATE taxonomy_node tn
        JOIN taxonomy_node p ON p.taxnode_id = tn.parent_id
        SET tn.molecule_id = NULL
        WHERE tn.molecule_id = p.inher_molecule_id
          AND tn.msl_release_num = current_msl;

        SET affected_rows = ROW_COUNT();
        IF affected_rows = 0 THEN
            LEAVE loop2;
        END IF;
    END WHILE loop2;

    
    
    
    
    
    

    
    
    
    
    

END
--------------

Query OK, 0 rows affected (0.006 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS species_isolates_update_sorts
--------------

Query OK, 0 rows affected (0.004 sec)

--------------
CREATE PROCEDURE species_isolates_update_sorts()
BEGIN
  UPDATE species_isolates si
  JOIN (
    SELECT
      vmr.isolate_id,
      DENSE_RANK() OVER (ORDER BY tn.left_idx) AS species_sort,
      ROW_NUMBER() OVER (
        PARTITION BY vmr.species_name
        ORDER BY
          vmr.isolate_type DESC,
          COALESCE(vmr._isolate_name_alpha,'') COLLATE utf8mb4_general_ci,
          COALESCE(vmr._isolate_name_num1,
                   vmr._isolate_name_num2,
                   18446744073709551615),
          vmr.isolate_id
      ) AS isolate_sort
    FROM species_isolates_alpha_num1_num2 AS vmr
    JOIN taxonomy_node AS tn
      ON tn.taxnode_id = vmr.taxnode_id
  ) AS x
    ON x.isolate_id = si.isolate_id
  SET
    si.species_sort = x.species_sort,
    si.isolate_sort = x.isolate_sort;
END
--------------

Query OK, 0 rows affected (0.004 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS NCBI_linkout_ft_export
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE NCBI_linkout_ft_export
(
    IN  p_msl      INT,          
    IN  p_newline  VARCHAR(10)   
)
BEGIN
	
    DECLARE v_provider_id  CHAR(4)   DEFAULT '7640';
	DECLARE v_base_url     VARCHAR(500)
    	DEFAULT 'https://ictv.global/taxonomy/taxondetails?taxnode_id=';
	
    
    IF p_msl IS NULL OR p_msl < 1 THEN
        SELECT MAX(msl_release_num) INTO p_msl
        FROM taxonomy_node;
    END IF;

    
    IF p_newline IS NULL THEN
        SET p_newline = '\r\n';      
        
        
        
    END IF;

    
    WITH header AS (
        
        SELECT 
              NULL AS left_idx
            , NULL AS msl_release_num
            , CONCAT(
                  '---------------------------------------------------------------', p_newline,
                  'prid:   ', v_LINKOUT_PROVIDER_ID,                      p_newline,
                  'dbase:  taxonomy',                                     p_newline,
                  'stype:  taxonomy/phylogenetic',                        p_newline,
                  '!base:  ', v_URL,                                      p_newline,
                  '---------------------------------------------------------------'
              ) AS t
    ),

    
    
    
    current_names AS (
        
        SELECT 
              MAX(tn.left_idx)                       AS left_idx
            , MAX(tn.msl_release_num)                AS msl_release_num
            , CONCAT(
                  'linkid:   ',  MAX(tn.taxnode_id),                   p_newline,
                  'query:  ',   tn.name, ' [name]',                    p_newline,
                  'base:  &base;',                                     p_newline,
                  'rule:  ',    MAX(tn.taxnode_id),                    p_newline,
                  'name:  ',    tn.name,                               p_newline,
                  '---------------------------------------------------------------'
              ) AS t
        FROM taxonomy_node_names tn
        WHERE tn.msl_release_num = p_msl               
          AND tn.is_deleted  = 0
          AND tn.is_hidden   = 0
          AND tn.is_obsolete = 0
          AND tn.name        IS NOT NULL
          AND tn.name        <> 'Unassigned'
        GROUP BY tn.name
    )

    
    SELECT t
    FROM   (
              SELECT * FROM header
              UNION ALL
              SELECT * FROM current_names
           ) AS src
    ORDER BY src.left_idx;

END
--------------

Query OK, 0 rows affected (0.006 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS taxonomy_node_compute_indexes
--------------

Query OK, 0 rows affected (0.007 sec)

--------------
CREATE PROCEDURE taxonomy_node_compute_indexes
(
    
    IN  p_taxnode_id        INT,
    IN  p_left_idx          INT,
    OUT p_right_idx         INT,
    IN  p_node_depth        INT,

    
    INOUT p_realm_id        INT,
    INOUT p_subrealm_id     INT,
    INOUT p_kingdom_id      INT,
    INOUT p_subkingdom_id   INT,
    INOUT p_phylum_id       INT,
    INOUT p_subphylum_id    INT,
    INOUT p_class_id        INT,
    INOUT p_subclass_id     INT,
    INOUT p_order_id        INT,
    INOUT p_suborder_id     INT,
    INOUT p_family_id       INT,
    INOUT p_subfamily_id    INT,
    INOUT p_genus_id        INT,
    INOUT p_subgenus_id     INT,
    INOUT p_species_id      INT,

    
    INOUT p_realm_desc_ct       INT,
    INOUT p_subrealm_desc_ct    INT,
    INOUT p_kingdom_desc_ct     INT,
    INOUT p_subkingdom_desc_ct  INT,
    INOUT p_phylum_desc_ct      INT,
    INOUT p_subphylum_desc_ct   INT,
    INOUT p_class_desc_ct       INT,
    INOUT p_subclass_desc_ct    INT,
    INOUT p_order_desc_ct       INT,
    INOUT p_suborder_desc_ct    INT,
    INOUT p_family_desc_ct      INT,
    INOUT p_subfamily_desc_ct   INT,
    INOUT p_genus_desc_ct       INT,
    INOUT p_subgenus_desc_ct    INT,
    INOUT p_species_desc_ct     INT,

    
    INOUT p_inher_molecule_id   INT,
    INOUT p_lineage             VARCHAR(1000)
)
BEGIN
    
    DECLARE v_hidden_as_unassigned   TINYINT  DEFAULT 1;
    DECLARE v_use_my_lineage         TINYINT;
    DECLARE v_my_lineage             VARCHAR(1000);

    
    DECLARE v_realm_kid_ct,      v_subrealm_kid_ct,  v_kingdom_kid_ct,
            v_subkingdom_kid_ct, v_phylum_kid_ct,    v_subphylum_kid_ct,
            v_class_kid_ct,      v_subclass_kid_ct,  v_order_kid_ct,
            v_suborder_kid_ct,   v_family_kid_ct,    v_subfamily_kid_ct,
            v_genus_kid_ct,      v_subgenus_kid_ct,  v_species_kid_ct  INT DEFAULT 0;

    
    DECLARE v_child_taxnode_id   INT;
    DECLARE v_child_rank         VARCHAR(50);
    DECLARE v_child_is_hidden    TINYINT;
    DECLARE v_child_depth        INT;

    
    DECLARE k_realm_desc_ct,      k_subrealm_desc_ct,  k_kingdom_desc_ct,
            k_subkingdom_desc_ct, k_phylum_desc_ct,    k_subphylum_desc_ct,
            k_class_desc_ct,      k_subclass_desc_ct,  k_order_desc_ct,
            k_suborder_desc_ct,   k_family_desc_ct,    k_subfamily_desc_ct,
            k_genus_desc_ct,      k_subgenus_desc_ct,  k_species_desc_ct  INT;
    
    
	IF p_left_idx   IS NULL THEN SET p_left_idx   := 1; END IF;
    IF p_node_depth IS NULL THEN SET p_node_depth := 1; END IF;

    
    SELECT
          
          IFNULL(p_realm_id      , CASE WHEN l.name='realm'       THEN n.taxnode_id END),
          IFNULL(p_subrealm_id   , CASE WHEN l.name='subrealm'    THEN n.taxnode_id END),
          IFNULL(p_kingdom_id    , CASE WHEN l.name='kingdom'     THEN n.taxnode_id END),
          IFNULL(p_subkingdom_id , CASE WHEN l.name='subkingdom'  THEN n.taxnode_id END),
          IFNULL(p_phylum_id     , CASE WHEN l.name='phylum'      THEN n.taxnode_id END),
          IFNULL(p_subphylum_id  , CASE WHEN l.name='subphylum'   THEN n.taxnode_id END),
          IFNULL(p_class_id      , CASE WHEN l.name='class'       THEN n.taxnode_id END),
          IFNULL(p_subclass_id   , CASE WHEN l.name='subclass'    THEN n.taxnode_id END),
          IFNULL(p_order_id      , CASE WHEN l.name='order'       THEN n.taxnode_id END),
          IFNULL(p_suborder_id   , CASE WHEN l.name='suborder'    THEN n.taxnode_id END),
          IFNULL(p_family_id     , CASE WHEN l.name='family'      THEN n.taxnode_id END),
          IFNULL(p_subfamily_id  , CASE WHEN l.name='subfamily'   THEN n.taxnode_id END),
          IFNULL(p_genus_id      , CASE WHEN l.name='genus'       THEN n.taxnode_id END),
          IFNULL(p_subgenus_id   , CASE WHEN l.name='subgenus'    THEN n.taxnode_id END),
          IFNULL(p_species_id    , CASE WHEN l.name='species'     THEN n.taxnode_id END),

          
          COALESCE(n.molecule_id , p_inher_molecule_id),

          
          CASE 
              WHEN n.taxnode_id = n.tree_id THEN 0
              WHEN v_hidden_as_unassigned   = 1 THEN 1
              WHEN n.is_hidden = 1 OR n.name IS NULL THEN 0
              ELSE 1
          END                                                AS use_my_lineage,

          
          CONCAT_WS('',
                    IFNULL(p_lineage,''),
                    IF(LENGTH(IFNULL(p_lineage,''))>0, ';', ''),
                    IF(n.is_hidden = 1 AND v_hidden_as_unassigned = 0, '[', ''),
                    IFNULL(n.name,
                           IF(v_hidden_as_unassigned = 1,'Unassigned','- unnamed -')
                    ),
                    IF(n.is_hidden = 1 AND v_hidden_as_unassigned = 0, ']', '')
          )                                                 AS my_lineage
     INTO  p_realm_id,   p_subrealm_id,  p_kingdom_id, p_subkingdom_id,
          p_phylum_id,   p_subphylum_id, p_class_id,   p_subclass_id,
          p_order_id,    p_suborder_id,  p_family_id,  p_subfamily_id,
          p_genus_id,    p_subgenus_id,  p_species_id,
          p_inher_molecule_id,
          v_use_my_lineage,
          v_my_lineage
     FROM  taxonomy_node  AS n
     JOIN  taxonomy_level AS l  ON l.id = n.level_id
     WHERE n.taxnode_id = p_taxnode_id;

    
    UPDATE taxonomy_node SET
          left_idx        = p_left_idx,
          node_depth      = p_node_depth,
          
          realm_id        = p_realm_id,
          subrealm_id     = p_subrealm_id,
          kingdom_id      = p_kingdom_id,
          subkingdom_id   = p_subkingdom_id,
          phylum_id       = p_phylum_id,
          subphylum_id    = p_subphylum_id,
          class_id        = p_class_id,
          subclass_id     = p_subclass_id,
          order_id        = p_order_id,
          suborder_id     = p_suborder_id,
          family_id       = p_family_id,
          subfamily_id    = p_subfamily_id,
          genus_id        = p_genus_id,
          subgenus_id     = p_subgenus_id,
          species_id      = p_species_id,
          inher_molecule_id = p_inher_molecule_id,
          lineage         = v_my_lineage
    WHERE taxnode_id = p_taxnode_id
      AND (
              left_idx          <> p_left_idx        OR left_idx        IS NULL
           OR node_depth        <> p_node_depth      OR node_depth      IS NULL
           OR realm_id          <> p_realm_id        OR (realm_id       IS NULL AND p_realm_id       IS NOT NULL)
           OR subrealm_id       <> p_subrealm_id     OR (subrealm_id    IS NULL AND p_subrealm_id    IS NOT NULL)
           OR kingdom_id        <> p_kingdom_id      OR (kingdom_id     IS NULL AND p_kingdom_id     IS NOT NULL)
           OR subkingdom_id     <> p_subkingdom_id   OR (subkingdom_id  IS NULL AND p_subkingdom_id  IS NOT NULL)
           OR phylum_id         <> p_phylum_id       OR (phylum_id      IS NULL AND p_phylum_id      IS NOT NULL)
           OR subphylum_id      <> p_subphylum_id    OR (subphylum_id   IS NULL AND p_subphylum_id   IS NOT NULL)
           OR class_id          <> p_class_id        OR (class_id       IS NULL AND p_class_id       IS NOT NULL)
           OR subclass_id       <> p_subclass_id     OR (subclass_id    IS NULL AND p_subclass_id    IS NOT NULL)
           OR order_id          <> p_order_id        OR (order_id       IS NULL AND p_order_id       IS NOT NULL)
           OR suborder_id       <> p_suborder_id     OR (suborder_id    IS NULL AND p_suborder_id    IS NOT NULL)
           OR family_id         <> p_family_id       OR (family_id      IS NULL AND p_family_id      IS NOT NULL)
           OR subfamily_id      <> p_subfamily_id    OR (subfamily_id   IS NULL AND p_subfamily_id   IS NOT NULL)
           OR genus_id          <> p_genus_id        OR (genus_id       IS NULL AND p_genus_id       IS NOT NULL)
           OR subgenus_id       <> p_subgenus_id     OR (subgenus_id    IS NULL AND p_subgenus_id    IS NOT NULL)
           OR species_id        <> p_species_id      OR (species_id     IS NULL AND p_species_id     IS NOT NULL)
           OR inher_molecule_id <> p_inher_molecule_id OR (inher_molecule_id IS NULL AND p_inher_molecule_id IS NOT NULL)
           OR lineage           <> v_my_lineage      OR (lineage        IS NULL AND v_my_lineage     IS NOT NULL)
      );

    
    IF v_use_my_lineage = 1 THEN
        SET p_lineage = v_my_lineage;
    END IF;

    
    SET p_right_idx = p_left_idx + 1;
    SET v_child_depth = p_node_depth + 1;

    child_loop: LOOP
        
        SELECT n.taxnode_id,
               n.is_hidden,
               l.name
          INTO v_child_taxnode_id,
               v_child_is_hidden,
               v_child_rank
          FROM taxonomy_node AS n
          JOIN taxonomy_level AS l  ON l.id = n.level_id
         WHERE n.parent_id   = p_taxnode_id
           AND n.taxnode_id <> p_taxnode_id
           AND n.left_idx   IS NULL
         ORDER BY n.level_id,
                  CASE
                       WHEN n.start_num_sort IS NULL
                              THEN IFNULL(n.name,'ZZZZ')
                       ELSE LEFT(n.name, n.start_num_sort)
                  END,
                  CASE
                       WHEN n.start_num_sort IS NULL
                              THEN NULL
                       ELSE CAST(
                       			TRIM(LEADING ' '
                       				FROM SUBSTRING(n.name, n.start_num_sort + 1)
                       ) AS UNSIGNED)
                  END
         LIMIT 1;

        
        IF v_child_taxnode_id IS NULL THEN
            LEAVE child_loop;
        END IF;

        
        SET k_realm_desc_ct      = 0;
        SET k_subrealm_desc_ct   = 0;
        SET k_kingdom_desc_ct    = 0;
        SET k_subkingdom_desc_ct = 0;
        SET k_phylum_desc_ct     = 0;
        SET k_subphylum_desc_ct  = 0;
        SET k_class_desc_ct      = 0;
        SET k_subclass_desc_ct   = 0;
        SET k_order_desc_ct      = 0;
        SET k_suborder_desc_ct   = 0;
        SET k_family_desc_ct     = 0;
        SET k_subfamily_desc_ct  = 0;
        SET k_genus_desc_ct      = 0;
        SET k_subgenus_desc_ct   = 0;
        SET k_species_desc_ct    = 0;

        CALL taxonomy_node_compute_indexes
        (
            v_child_taxnode_id,
            p_right_idx,
            p_right_idx,          
            v_child_depth,

            
            p_realm_id, p_subrealm_id, p_kingdom_id, p_subkingdom_id,
            p_phylum_id, p_subphylum_id, p_class_id, p_subclass_id,
            p_order_id, p_suborder_id, p_family_id, p_subfamily_id,
            p_genus_id, p_subgenus_id, p_species_id,

            
            k_realm_desc_ct,      k_subrealm_desc_ct,   k_kingdom_desc_ct,
            k_subkingdom_desc_ct, k_phylum_desc_ct,     k_subphylum_desc_ct,
            k_class_desc_ct,      k_subclass_desc_ct,   k_order_desc_ct,
            k_suborder_desc_ct,   k_family_desc_ct,     k_subfamily_desc_ct,
            k_genus_desc_ct,      k_subgenus_desc_ct,   k_species_desc_ct,

            
            p_inher_molecule_id,
            p_lineage
        );
            

        
        IF v_child_is_hidden = 0 THEN
            IF v_child_rank = 'realm'      THEN SET v_realm_kid_ct       = v_realm_kid_ct       + 1;
            ELSEIF v_child_rank = 'subrealm'   THEN SET v_subrealm_kid_ct    = v_subrealm_kid_ct    + 1;
            ELSEIF v_child_rank = 'kingdom'    THEN SET v_kingdom_kid_ct     = v_kingdom_kid_ct     + 1;
            ELSEIF v_child_rank = 'subkingdom' THEN SET v_subkingdom_kid_ct  = v_subkingdom_kid_ct  + 1;
            ELSEIF v_child_rank = 'phylum'     THEN SET v_phylum_kid_ct      = v_phylum_kid_ct      + 1;
            ELSEIF v_child_rank = 'subphylum'  THEN SET v_subphylum_kid_ct   = v_subphylum_kid_ct   + 1;
            ELSEIF v_child_rank = 'class'      THEN SET v_class_kid_ct       = v_class_kid_ct       + 1;
            ELSEIF v_child_rank = 'subclass'   THEN SET v_subclass_kid_ct    = v_subclass_kid_ct    + 1;
            ELSEIF v_child_rank = 'order'      THEN SET v_order_kid_ct       = v_order_kid_ct       + 1;
            ELSEIF v_child_rank = 'suborder'   THEN SET v_suborder_kid_ct    = v_suborder_kid_ct    + 1;
            ELSEIF v_child_rank = 'family'     THEN SET v_family_kid_ct      = v_family_kid_ct      + 1;
            ELSEIF v_child_rank = 'subfamily'  THEN SET v_subfamily_kid_ct   = v_subfamily_kid_ct   + 1;
            ELSEIF v_child_rank = 'genus'      THEN SET v_genus_kid_ct       = v_genus_kid_ct       + 1;
            ELSEIF v_child_rank = 'subgenus'   THEN SET v_subgenus_kid_ct    = v_subgenus_kid_ct    + 1;
            ELSEIF v_child_rank = 'species'    THEN SET v_species_kid_ct     = v_species_kid_ct     + 1;
        	END IF;
        END IF;


        SET p_realm_desc_ct       = p_realm_desc_ct       + k_realm_desc_ct;
        SET p_subrealm_desc_ct    = p_subrealm_desc_ct    + k_subrealm_desc_ct;
        SET p_kingdom_desc_ct     = p_kingdom_desc_ct     + k_kingdom_desc_ct;
        SET p_subkingdom_desc_ct  = p_subkingdom_desc_ct  + k_subkingdom_desc_ct;
        SET p_phylum_desc_ct      = p_phylum_desc_ct      + k_phylum_desc_ct;
        SET p_subphylum_desc_ct   = p_subphylum_desc_ct   + k_subphylum_desc_ct;
        SET p_class_desc_ct       = p_class_desc_ct       + k_class_desc_ct;
        SET p_subclass_desc_ct    = p_subclass_desc_ct    + k_subclass_desc_ct;
        SET p_order_desc_ct       = p_order_desc_ct       + k_order_desc_ct;
        SET p_suborder_desc_ct    = p_suborder_desc_ct    + k_suborder_desc_ct;
        SET p_family_desc_ct      = p_family_desc_ct      + k_family_desc_ct;
        SET p_subfamily_desc_ct   = p_subfamily_desc_ct   + k_subfamily_desc_ct;
        SET p_genus_desc_ct       = p_genus_desc_ct       + k_genus_desc_ct;
        SET p_subgenus_desc_ct    = p_subgenus_desc_ct    + k_subgenus_desc_ct;
        SET p_species_desc_ct     = p_species_desc_ct     + k_species_desc_ct;

        
        SET p_right_idx = p_right_idx + 1;
    END LOOP child_loop;

    
    SET p_realm_desc_ct       = p_realm_desc_ct       + v_realm_kid_ct;
    SET p_subrealm_desc_ct    = p_subrealm_desc_ct    + v_subrealm_kid_ct;
    SET p_kingdom_desc_ct     = p_kingdom_desc_ct     + v_kingdom_kid_ct;
    SET p_subkingdom_desc_ct  = p_subkingdom_desc_ct  + v_subkingdom_kid_ct;
    SET p_phylum_desc_ct      = p_phylum_desc_ct      + v_phylum_kid_ct;
    SET p_subphylum_desc_ct   = p_subphylum_desc_ct   + v_subphylum_kid_ct;
    SET p_class_desc_ct       = p_class_desc_ct       + v_class_kid_ct;
    SET p_subclass_desc_ct    = p_subclass_desc_ct    + v_subclass_kid_ct;
    SET p_order_desc_ct       = p_order_desc_ct       + v_order_kid_ct;
    SET p_suborder_desc_ct    = p_suborder_desc_ct    + v_suborder_kid_ct;
    SET p_family_desc_ct      = p_family_desc_ct      + v_family_kid_ct;
    SET p_subfamily_desc_ct   = p_subfamily_desc_ct   + v_subfamily_kid_ct;
    SET p_genus_desc_ct       = p_genus_desc_ct       + v_genus_kid_ct;
    SET p_subgenus_desc_ct    = p_subgenus_desc_ct    + v_subgenus_kid_ct;
    SET p_species_desc_ct     = p_species_desc_ct     + v_species_kid_ct;

    
    UPDATE taxonomy_node SET
          right_idx          = p_right_idx,

          realm_desc_ct      = p_realm_desc_ct      , realm_kid_ct      = v_realm_kid_ct,
          subrealm_desc_ct   = p_subrealm_desc_ct   , subrealm_kid_ct   = v_subrealm_kid_ct,
          kingdom_desc_ct    = p_kingdom_desc_ct    , kingdom_kid_ct    = v_kingdom_kid_ct,
          subkingdom_desc_ct = p_subkingdom_desc_ct , subkingdom_kid_ct = v_subkingdom_kid_ct,
          phylum_desc_ct     = p_phylum_desc_ct     , phylum_kid_ct     = v_phylum_kid_ct,
          subphylum_desc_ct  = p_subphylum_desc_ct  , subphylum_kid_ct  = v_subphylum_kid_ct,
          class_desc_ct      = p_class_desc_ct      , class_kid_ct      = v_class_kid_ct,
          subclass_desc_ct   = p_subclass_desc_ct   , subclass_kid_ct   = v_subclass_kid_ct,
          order_desc_ct      = p_order_desc_ct      , order_kid_ct      = v_order_kid_ct,
          suborder_desc_ct   = p_suborder_desc_ct   , suborder_kid_ct   = v_suborder_kid_ct,
          family_desc_ct     = p_family_desc_ct     , family_kid_ct     = v_family_kid_ct,
          subfamily_desc_ct  = p_subfamily_desc_ct  , subfamily_kid_ct  = v_subfamily_kid_ct,
          genus_desc_ct      = p_genus_desc_ct      , genus_kid_ct      = v_genus_kid_ct,
          subgenus_desc_ct   = p_subgenus_desc_ct   , subgenus_kid_ct   = v_subgenus_kid_ct,
          species_desc_ct    = p_species_desc_ct    , species_kid_ct    = v_species_kid_ct,

          
          taxa_kid_cts  = udf_rankCountsToStringWithPurals(
                              v_realm_kid_ct,      v_subrealm_kid_ct,
                              v_kingdom_kid_ct,    v_subkingdom_kid_ct,
                              v_phylum_kid_ct,     v_subphylum_kid_ct,
                              v_class_kid_ct,      v_subclass_kid_ct,
                              v_order_kid_ct,      v_suborder_kid_ct,
                              v_family_kid_ct,     v_subfamily_kid_ct,
                              v_genus_kid_ct,      v_subgenus_kid_ct,
                              v_species_kid_ct ),
          taxa_desc_cts = udf_rankCountsToStringWithPurals(
                              p_realm_desc_ct,      p_subrealm_desc_ct,
                              p_kingdom_desc_ct,    p_subkingdom_desc_ct,
                              p_phylum_desc_ct,     p_subphylum_desc_ct,
                              p_class_desc_ct,      p_subclass_desc_ct,
                              p_order_desc_ct,      p_suborder_desc_ct,
                              p_family_desc_ct,     p_subfamily_desc_ct,
                              p_genus_desc_ct,      p_subgenus_desc_ct,
                              p_species_desc_ct )
    WHERE taxnode_id = p_taxnode_id;
END
--------------

Query OK, 0 rows affected (0.011 sec)

Bye
--------------
DROP PROCEDURE IF EXISTS rebuild_node_merge_split
--------------

Query OK, 0 rows affected (0.006 sec)

--------------
CREATE PROCEDURE rebuild_node_merge_split()
BEGIN

    DECLARE v_rows BIGINT DEFAULT 1;
    
    START TRANSACTION;

    
    TRUNCATE TABLE taxonomy_node_merge_split;

    
    INSERT INTO taxonomy_node_merge_split
            (prev_ictv_id, next_ictv_id,
             is_merged, is_split, is_recreated,
             dist,       rev_count)
    SELECT  ictv_id, ictv_id,
            0,        0,        0,
            0,        0
    FROM    taxonomy_node
    WHERE   msl_release_num IS NOT NULL
      AND   is_hidden       = 0
    GROUP BY ictv_id;

    
    INSERT INTO taxonomy_node_merge_split
            (prev_ictv_id, next_ictv_id,
             is_merged, is_split, is_recreated,
             dist,       rev_count)
    SELECT  p.ictv_id,
            n.ictv_id,
            d.is_merged,
            d.is_split,
            0,
            1,
            0
    FROM    taxonomy_node_delta AS d
    JOIN    taxonomy_node       AS p ON  p.taxnode_id      = d.prev_taxid
    JOIN    taxonomy_node       AS n ON  n.taxnode_id      = d.new_taxid
    WHERE   p.level_id          > 100
      AND   n.level_id          > 100
      AND   p.ictv_id           <> n.ictv_id
      AND   p.msl_release_num   = n.msl_release_num - 1
      AND   p.is_hidden = 0
      AND   n.is_hidden = 0;

    
    INSERT INTO taxonomy_node_merge_split
            (prev_ictv_id, next_ictv_id,
             is_merged, is_split, is_recreated,
             dist,       rev_count)
    SELECT  n.ictv_id,
            p.ictv_id,
            d.is_merged,
            d.is_split,
            0,
            1,
            1           
    FROM    taxonomy_node_delta AS d
    JOIN    taxonomy_node       AS p ON p.taxnode_id = d.prev_taxid
    JOIN    taxonomy_node       AS n ON n.taxnode_id = d.new_taxid
    WHERE   p.level_id          > 100
      AND   n.level_id          > 100
      AND   p.ictv_id           <> n.ictv_id
      AND   p.msl_release_num   = n.msl_release_num - 1
      AND   p.is_hidden = 0
      AND   n.is_hidden = 0;

    
    INSERT INTO taxonomy_node_merge_split
            (prev_ictv_id, next_ictv_id,
             is_merged, is_split, is_recreated,
             dist,       rev_count)
    SELECT
        
        CASE WHEN dir.rev_count = 0 THEN early.ictv_id ELSE late.ictv_id END,
        CASE WHEN dir.rev_count = 0 THEN late.ictv_id  ELSE early.ictv_id END,
        0,                
        0,                
        1,                
        1,                
        dir.rev_count
    FROM  ( SELECT 0 AS rev_count UNION ALL SELECT 1 ) AS dir
    JOIN  taxonomy_node_dx  AS early
      ON  early.next_tags LIKE '%Abolish%'             
    JOIN  taxonomy_node_dx  AS late
      ON  late.name             = early.name
     AND  late.msl_release_num  > early.msl_release_num
     AND  late.ictv_id          <> early.ictv_id
     AND  late.level_id          = early.level_id
    WHERE NOT EXISTS (
             SELECT 1
             FROM   taxonomy_node_merge_split ms
             WHERE  ms.prev_ictv_id = early.ictv_id
               AND  ms.next_ictv_id = late.ictv_id
          );

    

    SELECT 'start closure' AS info;

    WHILE v_rows > 0 DO
        INSERT INTO taxonomy_node_merge_split
                (prev_ictv_id, next_ictv_id,
                 is_merged, is_split, is_recreated,
                 dist,       rev_count)
        SELECT  p.prev_ictv_id,
                n.next_ictv_id,
                MAX(p.is_merged + n.is_merged  > 0),
                MAX(p.is_split  + n.is_split   > 0),
                MAX(p.is_recreated + n.is_recreated > 0),
                MIN(p.dist + n.dist),
                SUM(p.rev_count + n.rev_count)
        FROM    taxonomy_node_merge_split AS p
        JOIN    taxonomy_node_merge_split AS n
               ON p.next_ictv_id = n.prev_ictv_id
        WHERE   p.dist > 0
          AND   n.dist > 0
        GROUP BY p.prev_ictv_id,
                 n.next_ictv_id
        HAVING  NOT EXISTS (
                   SELECT 1
                   FROM   taxonomy_node_merge_split cur
                   WHERE  cur.prev_ictv_id = p.prev_ictv_id
                     AND  cur.next_ictv_id = n.next_ictv_id
               );

        SET v_rows = ROW_COUNT();   
    END WHILE;

    SELECT 'closure done' AS info;

    COMMIT;
END
--------------

Query OK, 0 rows affected (0.006 sec)

Bye
--------------
CALL initializeTaxonomyJsonRanks()
--------------

Query OK, 281 rows affected (0.413 sec)

--------------
SET @autoIncVal := (
  SELECT COALESCE(MAX(id), 0) + 1
  FROM taxonomy_json_rank
)
--------------

Query OK, 0 rows affected (0.000 sec)

--------------
SET @sql = CONCAT('ALTER TABLE taxonomy_json_rank AUTO_INCREMENT = ', @autoIncVal)
--------------

Query OK, 0 rows affected (0.000 sec)

--------------
PREPARE st FROM @sql
--------------

Query OK, 0 rows affected (0.000 sec)
Statement prepared

--------------
EXECUTE st
--------------

Query OK, 0 rows affected (0.014 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
DEALLOCATE PREPARE st
--------------

Query OK, 0 rows affected (0.000 sec)

Bye
--------------
CALL populateTaxonomyJsonForAllReleases()
--------------

Query OK, 1171791 rows affected (6 min 24.245 sec)

--------------
SET @autoIncVal := (
  SELECT COALESCE(MAX(id), 0) + 1
  FROM taxonomy_json
)
--------------

Query OK, 0 rows affected (0.000 sec)

--------------
SET @sql = CONCAT('ALTER TABLE taxonomy_json AUTO_INCREMENT = ', @autoIncVal)
--------------

Query OK, 0 rows affected (0.000 sec)

--------------
PREPARE st FROM @sql
--------------

Query OK, 0 rows affected (0.000 sec)
Statement prepared

--------------
EXECUTE st
--------------

Query OK, 0 rows affected (0.225 sec)
Records: 0  Duplicates: 0  Warnings: 0

--------------
DEALLOCATE PREPARE st
--------------

Query OK, 0 rows affected (0.000 sec)

Bye
Total execution time: 12 minutes and 36 seconds
